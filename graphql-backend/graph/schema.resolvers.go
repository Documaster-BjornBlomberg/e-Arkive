package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.69

import (
	"context"
	"database/sql"
	"encoding/base64"
	"fmt"
	"graphql-backend/graph/model"
	"log"
	"time"

	_ "github.com/mattn/go-sqlite3"
	"golang.org/x/crypto/bcrypt"
)

// SaveFile är resolvern för saveFile-fältet
// Hanterar uppladdning av nya filer och deras metadata till databasen
func (r *mutationResolver) SaveFile(ctx context.Context, input model.FileInput) (*model.File, error) {
	logAction("Received request to save file")
	log.Printf("Saving file: %s", input.Name)

	// Verifierar att databasanslutningen är aktiv
	if r.DB == nil {
		log.Printf("Database connection is nil")
		return nil, fmt.Errorf("internal server error: database connection is not initialized")
	}

	// Dekodar base64-data till binär form
	fileData, err := base64.StdEncoding.DecodeString(input.FileData)
	if err != nil {
		log.Printf("Error decoding file data: %v", err)
		return nil, fmt.Errorf("invalid file data: %v", err)
	}

	// Default nodeId to 1 (root) if not specified
	nodeID := "1"
	if input.NodeID != nil && *input.NodeID != "" {
		// Verify that the node exists
		var exists bool
		err := r.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM nodes WHERE id = ?)", *input.NodeID).Scan(&exists)
		if err != nil {
			log.Printf("Error checking if node exists: %v", err)
			return nil, fmt.Errorf("failed to validate node: %v", err)
		}
		if !exists {
			log.Printf("Node with ID %s does not exist", *input.NodeID)
			return nil, fmt.Errorf("node not found")
		}
		nodeID = *input.NodeID
	}

	// Sparar filinformation och binär data i databasen
	result, err := r.DB.Exec(
		"INSERT INTO files (name, size, content_type, created_at, file_data, node_id) VALUES (?, ?, ?, datetime('now'), ?, ?)",
		input.Name, input.Size, input.ContentType, fileData, nodeID,
	)
	if err != nil {
		log.Printf("Error saving file to database: %v", err)
		return nil, fmt.Errorf("failed to save file: %v", err)
	}

	fileID, err := result.LastInsertId()
	if err != nil {
		log.Printf("Error retrieving last insert ID: %v", err)
		return nil, fmt.Errorf("failed to retrieve file ID: %v", err)
	}

	log.Printf("File saved to database with ID: %d", fileID)

	// Sparar metadata för filen
	for _, meta := range input.Metadata {
		_, err := r.DB.Exec(
			"INSERT INTO metadata (file_id, key, value) VALUES (?, ?, ?)",
			fileID, meta.Key, meta.Value,
		)
		if err != nil {
			log.Printf("Error saving metadata to database: %v", err)
			return nil, fmt.Errorf("failed to save metadata: %v", err)
		}
	}

	log.Printf("File and metadata saved successfully with ID: %d", fileID)

	// Konverterar metadata till rätt format för responsen
	metadata := make([]*model.Metadata, len(input.Metadata))
	for i, meta := range input.Metadata {
		metadata[i] = &model.Metadata{
			Key:   meta.Key,
			Value: meta.Value,
		}
	}

	// Convert nodeID to string pointer
	nodeIDStr := nodeID

	return &model.File{
		ID:          fmt.Sprintf("%d", fileID),
		Name:        input.Name,
		Size:        input.Size,
		ContentType: input.ContentType,
		CreatedAt:   time.Now().Format(time.RFC3339),
		FileData:    &input.FileData, // Skickar tillbaka base64-kodad data
		Metadata:    metadata,
		NodeID:      &nodeIDStr,
	}, nil
}

// deleteFile är resolvern för deleteFile-mutation
func (r *mutationResolver) DeleteFile(ctx context.Context, id string) (bool, error) {
	logAction(fmt.Sprintf("Attempting to delete file with ID: %s", id))

	if r.DB == nil {
		log.Printf("Database connection is nil")
		return false, fmt.Errorf("internal server error: database connection is not initialized")
	}

	// Ta bort filen och dess metadata från databasen
	result, err := r.DB.Exec("DELETE FROM files WHERE id = ?", id)
	if err != nil {
		log.Printf("Error deleting file with ID %s: %v", id, err)
		return false, fmt.Errorf("failed to delete file: %v", err)
	}

	affectedRows, err := result.RowsAffected()
	if err != nil {
		log.Printf("Error fetching affected rows for file ID %s: %v", id, err)
		return false, fmt.Errorf("failed to verify deletion: %v", err)
	}

	if affectedRows == 0 {
		log.Printf("No file found with ID: %s", id)
		return false, fmt.Errorf("file not found")
	}

	log.Printf("Successfully deleted file with ID: %s", id)
	return true, nil
}

// UpdateMetadata är resolvern för updateMetadata-mutation
// Uppdaterar metadata för en fil
func (r *mutationResolver) UpdateMetadata(ctx context.Context, fileID string, metadataInput []*model.MetadataInput) (*model.File, error) {
	logAction(fmt.Sprintf("Attempting to update metadata for file with ID: %s", fileID))

	if r.DB == nil {
		log.Printf("Database connection is nil")
		return nil, fmt.Errorf("internal server error: database connection is not initialized")
	}

	// Kontrollera att filen finns
	var exists bool
	err := r.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM files WHERE id = ?)", fileID).Scan(&exists)
	if err != nil {
		log.Printf("Error checking if file exists: %v", err)
		return nil, fmt.Errorf("failed to check if file exists: %v", err)
	}

	if !exists {
		log.Printf("No file found with ID: %s", fileID)
		return nil, fmt.Errorf("file not found")
	}

	// Starta en transaktion för att säkerställa att alla operationer lyckas eller misslyckas tillsammans
	tx, err := r.DB.Begin()
	if err != nil {
		log.Printf("Error starting transaction: %v", err)
		return nil, fmt.Errorf("failed to start transaction: %v", err)
	}
	defer func() {
		if err != nil {
			tx.Rollback()
		}
	}()

	// Ta bort befintlig metadata för filen
	_, err = tx.Exec("DELETE FROM metadata WHERE file_id = ?", fileID)
	if err != nil {
		log.Printf("Error deleting existing metadata: %v", err)
		return nil, fmt.Errorf("failed to delete existing metadata: %v", err)
	}

	// Lägg till ny metadata
	for _, meta := range metadataInput {
		_, err := tx.Exec(
			"INSERT INTO metadata (file_id, key, value) VALUES (?, ?, ?)",
			fileID, meta.Key, meta.Value,
		)
		if err != nil {
			log.Printf("Error inserting metadata: %v", err)
			return nil, fmt.Errorf("failed to insert metadata: %v", err)
		}
	}

	// Commit transaktionen
	if err = tx.Commit(); err != nil {
		log.Printf("Error committing transaction: %v", err)
		return nil, fmt.Errorf("failed to commit transaction: %v", err)
	}

	log.Printf("Successfully updated metadata for file with ID: %s", fileID)

	// Hämta den uppdaterade filen för att returnera
	return (&queryResolver{r.Resolver}).GetFile(ctx, fileID)
}

// DeleteMetadata är resolvern för deleteMetadata-mutation
// Tar bort specifik metadata från en fil baserat på nycklar
func (r *mutationResolver) DeleteMetadata(ctx context.Context, fileID string, keys []string) (*model.File, error) {
	logAction(fmt.Sprintf("Attempting to delete metadata for file with ID: %s", fileID))

	if r.DB == nil {
		log.Printf("Database connection is nil")
		return nil, fmt.Errorf("internal server error: database connection is not initialized")
	}

	// Kontrollera att filen finns
	var exists bool
	err := r.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM files WHERE id = ?)", fileID).Scan(&exists)
	if err != nil {
		log.Printf("Error checking if file exists: %v", err)
		return nil, fmt.Errorf("failed to check if file exists: %v", err)
	}

	if !exists {
		log.Printf("No file found with ID: %s", fileID)
		return nil, fmt.Errorf("file not found")
	}

	// Starta en transaktion
	tx, err := r.DB.Begin()
	if err != nil {
		log.Printf("Error starting transaction: %v", err)
		return nil, fmt.Errorf("failed to start transaction: %v", err)
	}
	defer func() {
		if err != nil {
			tx.Rollback()
		}
	}()

	// Ta bort metadata baserat på nycklar
	for _, key := range keys {
		_, err := tx.Exec("DELETE FROM metadata WHERE file_id = ? AND key = ?", fileID, key)
		if err != nil {
			log.Printf("Error deleting metadata with key %s: %v", key, err)
			return nil, fmt.Errorf("failed to delete metadata: %v", err)
		}
	}

	// Commit transaktionen
	if err = tx.Commit(); err != nil {
		log.Printf("Error committing transaction: %v", err)
		return nil, fmt.Errorf("failed to commit transaction: %v", err)
	}

	log.Printf("Successfully deleted metadata for file with ID: %s", fileID)

	// Hämta den uppdaterade filen för att returnera
	return (&queryResolver{r.Resolver}).GetFile(ctx, fileID)
}

// MoveFile moves a file to a different node
func (r *mutationResolver) MoveFile(ctx context.Context, fileID string, nodeID string) (*model.File, error) {
	logAction(fmt.Sprintf("Moving file %s to node %s", fileID, nodeID))

	// Verify the file exists
	var fileExists bool
	err := r.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM files WHERE id = ?)", fileID).Scan(&fileExists)
	if err != nil {
		log.Printf("Error checking if file exists: %v", err)
		return nil, fmt.Errorf("failed to verify file: %v", err)
	}
	if !fileExists {
		log.Printf("File with ID %s does not exist", fileID)
		return nil, fmt.Errorf("file not found")
	}

	// Verify the node exists
	var nodeExists bool
	err = r.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM nodes WHERE id = ?)", nodeID).Scan(&nodeExists)
	if err != nil {
		log.Printf("Error checking if node exists: %v", err)
		return nil, fmt.Errorf("failed to verify node: %v", err)
	}
	if !nodeExists {
		log.Printf("Node with ID %s does not exist", nodeID)
		return nil, fmt.Errorf("node not found")
	}

	// Update the file's node_id
	_, err = r.DB.Exec("UPDATE files SET node_id = ? WHERE id = ?", nodeID, fileID)
	if err != nil {
		log.Printf("Error updating file node_id: %v", err)
		return nil, fmt.Errorf("failed to update file: %v", err)
	}

	// Get the updated file with all necessary information
	var file model.File
	var createdAt string

	err = r.DB.QueryRow(`
		SELECT id, name, size, content_type, created_at
		FROM files WHERE id = ?`, fileID).Scan(
		&file.ID, &file.Name, &file.Size, &file.ContentType, &createdAt)

	if err != nil {
		log.Printf("Error fetching updated file data: %v", err)
		return nil, fmt.Errorf("file updated but failed to retrieve updated data: %v", err)
	}

	file.CreatedAt = createdAt
	file.NodeID = &nodeID

	// Fetch metadata for the file
	metaRows, err := r.DB.Query("SELECT key, value FROM metadata WHERE file_id = ?", fileID)
	if err != nil {
		log.Printf("Error fetching metadata for file ID %s: %v", fileID, err)
		return nil, fmt.Errorf("failed to fetch metadata: %v", err)
	}
	defer metaRows.Close()

	var metadata []*model.Metadata
	for metaRows.Next() {
		var meta model.Metadata
		if err := metaRows.Scan(&meta.Key, &meta.Value); err != nil {
			log.Printf("Error scanning metadata row: %v", err)
			return nil, fmt.Errorf("failed to scan metadata row: %v", err)
		}
		metadata = append(metadata, &meta)
	}
	file.Metadata = metadata

	// Fetch the node data so the file has a reference to its node
	node, err := getNodeById(ctx, r.DB, nodeID)
	if err != nil {
		log.Printf("Warning: Failed to fetch node data for the file: %v", err)
		// Continue without the node data as it's not critical
	} else {
		file.Node = node
	}

	log.Printf("Successfully moved file ID %s to node ID %s", fileID, nodeID)
	return &file, nil
}

// CreateNode är resolvern för createNode-mutation
// Skapar en ny nod med ett valfritt parent ID
func (r *mutationResolver) CreateNode(ctx context.Context, input model.NodeInput) (*model.Node, error) {
	logAction(fmt.Sprintf("Attempting to create node with name: %s", input.Name))

	if r.DB == nil {
		log.Printf("Database connection is nil")
		return nil, fmt.Errorf("internal server error: database connection is not initialized")
	}

	// Validera parent_id om det är angivet
	if input.ParentID != nil {
		var exists bool
		err := r.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM nodes WHERE id = ?)", *input.ParentID).Scan(&exists)
		if err != nil {
			log.Printf("Error checking if parent node exists: %v", err)
			return nil, fmt.Errorf("failed to check if parent node exists: %v", err)
		}

		if !exists {
			log.Printf("Parent node with ID %s does not exist", *input.ParentID)
			return nil, fmt.Errorf("parent node not found")
		}
	}

	// Skapa den nya noden
	now := time.Now().Format(time.RFC3339)
	var result sql.Result
	var err error

	if input.ParentID != nil {
		result, err = r.DB.Exec(
			"INSERT INTO nodes (name, parent_id, created_at, updated_at) VALUES (?, ?, ?, ?)",
			input.Name, input.ParentID, now, now,
		)
	} else {
		result, err = r.DB.Exec(
			"INSERT INTO nodes (name, created_at, updated_at) VALUES (?, ?, ?)",
			input.Name, now, now,
		)
	}

	if err != nil {
		log.Printf("Error creating node: %v", err)
		return nil, fmt.Errorf("failed to create node: %v", err)
	}

	nodeID, err := result.LastInsertId()
	if err != nil {
		log.Printf("Error retrieving last insert ID: %v", err)
		return nil, fmt.Errorf("failed to retrieve node ID: %v", err)
	}

	log.Printf("Node created successfully with ID: %d", nodeID)

	// Returnera den skapade noden
	node := &model.Node{
		ID:        fmt.Sprintf("%d", nodeID),
		Name:      input.Name,
		CreatedAt: now,
		UpdatedAt: now,
	}

	if input.ParentID != nil {
		node.ParentID = input.ParentID
	}

	return node, nil
}

// UpdateNode är resolvern för updateNode-mutation
// Uppdaterar en befintlig nod med nytt namn och/eller parent ID
func (r *mutationResolver) UpdateNode(ctx context.Context, id string, input model.NodeUpdateInput) (*model.Node, error) {
	logAction(fmt.Sprintf("Attempting to update node with ID: %s", id))

	if r.DB == nil {
		log.Printf("Database connection is nil")
		return nil, fmt.Errorf("internal server error: database connection is not initialized")
	}

	// Kontrollera att noden finns
	var exists bool
	err := r.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM nodes WHERE id = ?)", id).Scan(&exists)
	if err != nil {
		log.Printf("Error checking if node exists: %v", err)
		return nil, fmt.Errorf("failed to check if node exists: %v", err)
	}

	if !exists {
		log.Printf("Node with ID %s does not exist", id)
		return nil, fmt.Errorf("node not found")
	}

	// Om parentId är uppdaterat, kontrollera att den nya föräldern existerar
	if input.ParentID != nil {
		// Kontrollera om den nya föräldern finns
		var parentExists bool
		err := r.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM nodes WHERE id = ?)", *input.ParentID).Scan(&parentExists)
		if err != nil {
			log.Printf("Error checking if parent node exists: %v", err)
			return nil, fmt.Errorf("failed to check if parent node exists: %v", err)
		}

		if !parentExists {
			log.Printf("Parent node with ID %s does not exist", *input.ParentID)
			return nil, fmt.Errorf("parent node not found")
		}

		// Kontrollera att den nya föräldern inte är en av barnens barn (cykeldetektion)
		var isCycle bool
		err = r.detectCycle(id, *input.ParentID, &isCycle)
		if err != nil {
			log.Printf("Error detecting cycle: %v", err)
			return nil, fmt.Errorf("failed to validate hierarchy: %v", err)
		}

		if isCycle {
			log.Printf("Cannot update node: would create a cycle in the hierarchy")
			return nil, fmt.Errorf("cannot update node: would create a cycle in the hierarchy")
		}
	}

	// Bygga update query dynamiskt baserat på vilka fält som ska uppdateras
	query := "UPDATE nodes SET updated_at = datetime('now')"
	args := []interface{}{}

	if input.Name != nil {
		query += ", name = ?"
		args = append(args, *input.Name)
	}

	if input.ParentID != nil {
		query += ", parent_id = ?"
		args = append(args, *input.ParentID)
	} else if input.ParentID == nil {
		// Om parent_id explicit sätts till null
		query += ", parent_id = NULL"
	}

	query += " WHERE id = ?"
	args = append(args, id)

	// Utför uppdateringen
	_, err = r.DB.Exec(query, args...)
	if err != nil {
		log.Printf("Error updating node: %v", err)
		return nil, fmt.Errorf("failed to update node: %v", err)
	}

	log.Printf("Node with ID %s updated successfully", id)

	// Hämta den uppdaterade noden från databasen
	return getNodeById(ctx, r.DB, id)
}

// DeleteNode är resolvern för deleteNode-mutation
// Tar bort en nod om den inte har några barn
func (r *mutationResolver) DeleteNode(ctx context.Context, id string) (bool, error) {
	logAction(fmt.Sprintf("Attempting to delete node with ID: %s", id))

	if r.DB == nil {
		log.Printf("Database connection is nil")
		return false, fmt.Errorf("internal server error: database connection is not initialized")
	}

	// Kontrollera att noden finns
	var exists bool
	err := r.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM nodes WHERE id = ?)", id).Scan(&exists)
	if err != nil {
		log.Printf("Error checking if node exists: %v", err)
		return false, fmt.Errorf("failed to check if node exists: %v", err)
	}

	if !exists {
		log.Printf("Node with ID %s does not exist", id)
		return false, fmt.Errorf("node not found")
	}

	// Kontrollera om noden har barn
	var hasChildren bool
	err = r.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM nodes WHERE parent_id = ?)", id).Scan(&hasChildren)
	if err != nil {
		log.Printf("Error checking if node has children: %v", err)
		return false, fmt.Errorf("failed to check if node has children: %v", err)
	}

	if hasChildren {
		log.Printf("Cannot delete node with ID %s: has children nodes", id)
		return false, fmt.Errorf("cannot delete node: has children nodes")
	}

	// Ta bort noden
	result, err := r.DB.Exec("DELETE FROM nodes WHERE id = ?", id)
	if err != nil {
		log.Printf("Error deleting node with ID %s: %v", id, err)
		return false, fmt.Errorf("failed to delete node: %v", err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		log.Printf("Error getting rows affected: %v", err)
		return false, fmt.Errorf("error confirming deletion: %v", err)
	}

	if rowsAffected == 0 {
		log.Printf("No rows deleted for node with ID %s", id)
		return false, nil
	}

	log.Printf("Node with ID %s deleted successfully", id)
	return true, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, username string, password string) (*model.AuthPayload, error) {
	logAction(fmt.Sprintf("Login attempt for user: %s", username))

	if r.DB == nil {
		log.Printf("Database connection is nil")
		return nil, fmt.Errorf("internal server error: database connection is not initialized")
	}

	// Query the database for the user with the provided username
	var id string
	var passwordHash string
	var name string
	err := r.DB.QueryRow("SELECT id, password_hash, username FROM users WHERE username = ?", username).Scan(&id, &passwordHash, &name)

	// Check if user exists
	if err == sql.ErrNoRows {
		log.Printf("User not found: %s", username)
		return nil, fmt.Errorf("invalid username or password")
	} else if err != nil {
		log.Printf("Error querying user: %v", err)
		return nil, fmt.Errorf("internal server error: %v", err)
	}

	// Compare the provided password with the stored hash
	err = bcrypt.CompareHashAndPassword([]byte(passwordHash), []byte(password))
	if err != nil {
		log.Printf("Invalid password for user: %s", username)
		return nil, fmt.Errorf("invalid username or password")
	}

	// Generate JWT token
	token, err := generateJWT(id, username)
	if err != nil {
		log.Printf("Error generating JWT token: %v", err)
		return nil, fmt.Errorf("internal server error: %v", err)
	}

	// Return the auth payload
	return &model.AuthPayload{
		Token: token,
		User: &model.User{
			ID:       id,
			Name:     name,
			Username: username,
		},
	}, nil
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, username string, password string) (*model.AuthPayload, error) {
	logAction(fmt.Sprintf("Registration attempt for user: %s", username))

	if r.DB == nil {
		log.Printf("Database connection is nil")
		return nil, fmt.Errorf("internal server error: database connection is not initialized")
	}

	// Check if username already exists
	var exists bool
	err := r.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM users WHERE username = ?)", username).Scan(&exists)
	if err != nil {
		log.Printf("Error checking if user exists: %v", err)
		return nil, fmt.Errorf("internal server error: %v", err)
	}

	if exists {
		log.Printf("Username already taken: %s", username)
		return nil, fmt.Errorf("username already taken")
	}

	// Hash the password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		log.Printf("Error hashing password: %v", err)
		return nil, fmt.Errorf("internal server error: %v", err)
	}

	// Start a transaction
	tx, err := r.DB.Begin()
	if err != nil {
		log.Printf("Error starting transaction: %v", err)
		return nil, fmt.Errorf("internal server error: %v", err)
	}
	defer func() {
		if err != nil {
			tx.Rollback()
		}
	}()

	// Insert the new user
	result, err := tx.Exec(
		"INSERT INTO users (username, password_hash, created_at) VALUES (?, ?, datetime('now'))",
		username, string(hashedPassword),
	)
	if err != nil {
		log.Printf("Error inserting user: %v", err)
		return nil, fmt.Errorf("internal server error: %v", err)
	}

	// Get the user ID
	userID, err := result.LastInsertId()
	if err != nil {
		log.Printf("Error retrieving user ID: %v", err)
		return nil, fmt.Errorf("internal server error: %v", err)
	}

	// Commit the transaction
	if err = tx.Commit(); err != nil {
		log.Printf("Error committing transaction: %v", err)
		return nil, fmt.Errorf("internal server error: %v", err)
	}

	// Generate JWT token
	token, err := generateJWT(fmt.Sprintf("%d", userID), username)
	if err != nil {
		log.Printf("Error generating JWT token: %v", err)
		return nil, fmt.Errorf("internal server error: %v", err)
	}

	log.Printf("User registered successfully: %s", username)

	// Return the auth payload
	return &model.AuthPayload{
		Token: token,
		User: &model.User{
			ID:       fmt.Sprintf("%d", userID),
			Name:     username,
			Username: username,
		},
	}, nil
}

// GetFiles är resolvern för getFiles-fältet
// Hämtar alla filer från databasen med tillhörande metadata
func (r *queryResolver) GetFiles(ctx context.Context) ([]*model.File, error) {
	logAction("Fetching all files from the database")

	// Hämtar alla filer från databasen
	rows, err := r.DB.Query("SELECT id, name, size, content_type, created_at, file_data, node_id FROM files")
	if err != nil {
		log.Printf("Error fetching files from database: %v", err)
		return nil, fmt.Errorf("failed to fetch files: %v", err)
	}
	defer rows.Close()

	var files []*model.File
	for rows.Next() {
		var file model.File
		var createdAt string
		var fileData []byte
		var nodeID sql.NullString
		if err := rows.Scan(&file.ID, &file.Name, &file.Size, &file.ContentType, &createdAt, &fileData, &nodeID); err != nil {
			log.Printf("Error scanning file row: %v", err)
			return nil, fmt.Errorf("failed to scan file row: %v", err)
		}
		file.CreatedAt = createdAt
		if fileData != nil {
			encodedFileData := base64.StdEncoding.EncodeToString(fileData)
			file.FileData = &encodedFileData
		}

		// Set the nodeId on the file
		if nodeID.Valid {
			nodeIDStr := nodeID.String
			file.NodeID = &nodeIDStr
		}

		// Hämtar metadata för varje fil
		metaRows, err := r.DB.Query("SELECT key, value FROM metadata WHERE file_id = ?", file.ID)
		if err != nil {
			log.Printf("Error fetching metadata for file ID %s: %v", file.ID, err)
			return nil, fmt.Errorf("failed to fetch metadata: %v", err)
		}
		defer metaRows.Close()

		var metadata []*model.Metadata
		for metaRows.Next() {
			var meta model.Metadata
			if err := metaRows.Scan(&meta.Key, &meta.Value); err != nil {
				log.Printf("Error scanning metadata row: %v", err)
				return nil, fmt.Errorf("failed to scan metadata row: %v", err)
			}
			metadata = append(metadata, &meta)
		}
		file.Metadata = metadata
		files = append(files, &file)
	}

	if err := rows.Err(); err != nil {
		log.Printf("Error iterating over file rows: %v", err)
		return nil, fmt.Errorf("failed to iterate over file rows: %v", err)
	}

	log.Printf("Successfully fetched %d files", len(files))
	return files, nil
}

// GetFile är resolvern för getFile-fältet
// Hämtar en specifik fil baserat på ID utan binärdata
func (r *queryResolver) GetFile(ctx context.Context, id string) (*model.File, error) {
	logAction(fmt.Sprintf("Fetching file with ID: %s", id))

	if r.DB == nil {
		err := fmt.Errorf("database connection is not initialized")
		log.Printf("GetFile failed: %v", err)
		return nil, err
	}

	// Hämtar filinformation från databasen utan binärdata
	var file model.File
	var createdAt string
	err := r.DB.QueryRow(`
		SELECT id, name, size, content_type, created_at
		FROM files WHERE id = ?`, id).Scan(
		&file.ID, &file.Name, &file.Size, &file.ContentType, &createdAt)

	if err == sql.ErrNoRows {
		errMsg := fmt.Sprintf("file not found with ID: %s", id)
		log.Printf("GetFile failed: %s", errMsg)
		return nil, fmt.Errorf(errMsg)
	} else if err != nil {
		log.Printf("GetFile failed: Error fetching file with ID %s: %v", id, err)
		return nil, fmt.Errorf("failed to fetch file: %v", err)
	}

	file.CreatedAt = createdAt

	// Hämtar metadata för filen
	metaRows, err := r.DB.Query("SELECT key, value FROM metadata WHERE file_id = ?", file.ID)
	if err != nil {
		log.Printf("Error fetching metadata for file ID %s: %v", file.ID, err)
		return nil, fmt.Errorf("failed to fetch metadata: %v", err)
	}
	defer metaRows.Close()

	var metadata []*model.Metadata
	for metaRows.Next() {
		var meta model.Metadata
		if err := metaRows.Scan(&meta.Key, &meta.Value); err != nil {
			log.Printf("Error scanning metadata row: %v", err)
			return nil, fmt.Errorf("failed to scan metadata row: %v", err)
		}
		metadata = append(metadata, &meta)
	}
	file.Metadata = metadata

	log.Printf("Successfully fetched file %s (ID: %s)", file.Name, file.ID)
	return &file, nil
}

// DownloadFile är resolvern för downloadFile-fältet
// Hämtar en fil för nedladdning baserat på ID
func (r *queryResolver) DownloadFile(ctx context.Context, id string) (*model.File, error) {
	logAction(fmt.Sprintf("Attempting to download file with ID: %s", id))

	if r.DB == nil {
		err := fmt.Errorf("database connection is not initialized")
		log.Printf("Download failed: %v", err)
		return nil, err
	}

	// Hämtar filinformation från databasen
	var file model.File
	var createdAt string
	var fileData []byte
	err := r.DB.QueryRow(`
		SELECT id, name, size, content_type, created_at, file_data 
		FROM files WHERE id = ?`, id).Scan(
		&file.ID, &file.Name, &file.Size, &file.ContentType, &createdAt, &fileData)

	if err == sql.ErrNoRows {
		errMsg := fmt.Sprintf("file not found with ID: %s", id)
		log.Printf("Download failed: %s", errMsg)
		return nil, fmt.Errorf(errMsg)
	} else if err != nil {
		log.Printf("Download failed: Error fetching file with ID %s: %v", id, err)
		return nil, fmt.Errorf("failed to fetch file: %v", err)
	}

	file.CreatedAt = createdAt
	if fileData != nil {
		encodedFileData := base64.StdEncoding.EncodeToString(fileData)
		file.FileData = &encodedFileData
	}

	// Hämtar metadata för filen
	metaRows, err := r.DB.Query("SELECT key, value FROM metadata WHERE file_id = ?", file.ID)
	if err != nil {
		log.Printf("Error fetching metadata for file ID %s: %v", file.ID, err)
		return nil, fmt.Errorf("failed to fetch metadata: %v", err)
	}
	defer metaRows.Close()

	var metadata []*model.Metadata
	for metaRows.Next() {
		var meta model.Metadata
		if err := metaRows.Scan(&meta.Key, &meta.Value); err != nil {
			log.Printf("Error scanning metadata row: %v", err)
			return nil, fmt.Errorf("failed to scan metadata row: %v", err)
		}
		metadata = append(metadata, &meta)
	}
	file.Metadata = metadata

	log.Printf("Successfully prepared file %s (ID: %s) for download", file.Name, file.ID)
	return &file, nil
}

// Correcting the method name to match the expected interface
func (r *queryResolver) GetFilesByNodeID(ctx context.Context, nodeID string) ([]*model.File, error) {
	return r.GetFilesByNodeId(ctx, nodeID)
}

// GetRootNodes hämtar alla noder som inte har någon förälder (top-level noder)
func (r *queryResolver) GetRootNodes(ctx context.Context) ([]*model.Node, error) {
	logAction("Fetching root nodes")

	if r.DB == nil {
		return nil, fmt.Errorf("database connection is not initialized")
	}

	rows, err := r.DB.Query(`
		SELECT id, name, parent_id, created_at, updated_at 
		FROM nodes 
		WHERE parent_id IS NULL
		ORDER BY name ASC
	`)
	if err != nil {
		log.Printf("Error fetching root nodes: %v", err)
		return nil, fmt.Errorf("failed to fetch root nodes: %v", err)
	}
	defer rows.Close()

	return scanNodeRows(rows)
}

// GetNodeByID is the resolver for the getNodeById field.
func (r *queryResolver) GetNodeByID(ctx context.Context, id string) (*model.Node, error) {
	panic(fmt.Errorf("not implemented: GetNodeByID - getNodeById"))
}

// GetChildNodes hämtar alla noder som har ett specifikt förälder-ID
func (r *queryResolver) GetChildNodes(ctx context.Context, parentID string) ([]*model.Node, error) {
	logAction(fmt.Sprintf("Fetching child nodes for parent ID: %s", parentID))

	if r.DB == nil {
		return nil, fmt.Errorf("database connection is not initialized")
	}

	// Kontrollera att föräldern finns
	var exists bool
	err := r.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM nodes WHERE id = ?)", parentID).Scan(&exists)
	if err != nil {
		log.Printf("Error checking if parent node exists: %v", err)
		return nil, fmt.Errorf("failed to check if parent node exists: %v", err)
	}

	if !exists {
		log.Printf("Parent node with ID %s does not exist", parentID)
		return nil, fmt.Errorf("parent node not found")
	}

	rows, err := r.DB.Query(`
		SELECT id, name, parent_id, created_at, updated_at 
		FROM nodes 
		WHERE parent_id = ?
		ORDER BY name ASC
	`, parentID)
	if err != nil {
		log.Printf("Error fetching child nodes: %v", err)
		return nil, fmt.Errorf("failed to fetch child nodes: %v", err)
	}
	defer rows.Close()

	return scanNodeRows(rows)
}

// Hello implementerar Query.hello
func (r *queryResolver) Hello(ctx context.Context) (string, error) {
	return "Hello from GraphQL!", nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	logAction("Fetching current user from JWT token")

	// Get the token from the context
	token, ok := GetAuthToken(ctx)
	if !ok {
		return nil, fmt.Errorf("not authenticated")
	}

	// Parse and validate the token
	claims, err := validateJWT(token)
	if err != nil {
		log.Printf("Error validating JWT token: %v", err)
		return nil, fmt.Errorf("not authenticated")
	}

	// Get user ID from claims
	userID, ok := claims["user_id"].(string)
	if !ok {
		log.Printf("Invalid token claims: user_id not found")
		return nil, fmt.Errorf("invalid authentication token")
	}

	// Get username from claims
	username, ok := claims["username"].(string)
	if !ok {
		log.Printf("Invalid token claims: username not found")
		return nil, fmt.Errorf("invalid authentication token")
	}

	// Return user information
	return &model.User{
		ID:       userID,
		Name:     username, // Using username as name for simplicity
		Username: username,
	}, nil
}

// User implementerar Todo.user
func (r *todoResolver) User(ctx context.Context, obj *model.Todo) (*model.User, error) {
	return &model.User{
		ID:   "1", // Exempel-ID eftersom detta är en dummy-implementation
		Name: "Example User",
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Todo returns TodoResolver implementation.
func (r *Resolver) Todo() TodoResolver { return &todoResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type todoResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.
/*
	func logAction(action string) {
	log.Printf("[ACTION] %s", action)
}
func (r *queryResolver) GetFilesByNodeId(ctx context.Context, nodeID string) ([]*model.File, error) {
	logAction(fmt.Sprintf("Fetching files for node ID: %s", nodeID))

	if r.DB == nil {
		log.Printf("Database connection is nil")
		return nil, fmt.Errorf("internal server error: database connection is not initialized")
	}

	// Verify the node exists
	var exists bool
	err := r.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM nodes WHERE id = ?)", nodeID).Scan(&exists)
	if err != nil {
		log.Printf("Error checking if node exists: %v", err)
		return nil, fmt.Errorf("failed to verify node: %v", err)
	}
	if !exists {
		log.Printf("Node with ID %s does not exist", nodeID)
		return nil, fmt.Errorf("node not found")
	}

	// Query files for this specific node
	rows, err := r.DB.Query(`
		SELECT id, name, size, content_type, created_at, file_data
		FROM files
		WHERE node_id = ?
		ORDER BY name ASC
	`, nodeID)
	if err != nil {
		log.Printf("Error fetching files for node ID %s: %v", nodeID, err)
		return nil, fmt.Errorf("failed to fetch files: %v", err)
	}
	defer rows.Close()

	var files []*model.File
	for rows.Next() {
		var file model.File
		var createdAt string
		var fileData []byte
		if err := rows.Scan(&file.ID, &file.Name, &file.Size, &file.ContentType, &createdAt, &fileData); err != nil {
			log.Printf("Error scanning file row: %v", err)
			return nil, fmt.Errorf("failed to scan file row: %v", err)
		}
		file.CreatedAt = createdAt

		// Don't send file data in listing, only metadata
		// We'll only include the file data when explicitly downloading the file

		// Set the nodeId on the file
		file.NodeID = &nodeID

		// Fetch metadata for each file
		metaRows, err := r.DB.Query("SELECT key, value FROM metadata WHERE file_id = ?", file.ID)
		if err != nil {
			log.Printf("Error fetching metadata for file ID %s: %v", file.ID, err)
			return nil, fmt.Errorf("failed to fetch metadata: %v", err)
		}

		var metadata []*model.Metadata
		for metaRows.Next() {
			var meta model.Metadata
			if err := metaRows.Scan(&meta.Key, &meta.Value); err != nil {
				log.Printf("Error scanning metadata row: %v", err)
				metaRows.Close()
				return nil, fmt.Errorf("failed to scan metadata row: %v", err)
			}
			metadata = append(metadata, &meta)
		}
		metaRows.Close()

		file.Metadata = metadata
		files = append(files, &file)
	}

	if err := rows.Err(); err != nil {
		log.Printf("Error iterating over file rows: %v", err)
		return nil, fmt.Errorf("failed to iterate over file rows: %v", err)
	}

	log.Printf("Successfully fetched %d files for node ID %s", len(files), nodeID)
	return files, nil
}
func (r *queryResolver) GetNodeById(ctx context.Context, id string) (*model.Node, error) {
	return getNodeById(ctx, r.DB, id)
}
func getNodeById(ctx context.Context, db *sql.DB, id string) (*model.Node, error) {
	logAction(fmt.Sprintf("Fetching node with ID: %s", id))

	if db == nil {
		return nil, fmt.Errorf("database connection is not initialized")
	}

	row := db.QueryRow(`
		SELECT id, name, parent_id, created_at, updated_at
		FROM nodes
		WHERE id = ?
	`, id)

	var node model.Node
	var parentID sql.NullString
	err := row.Scan(&node.ID, &node.Name, &parentID, &node.CreatedAt, &node.UpdatedAt)

	if err == sql.ErrNoRows {
		log.Printf("Node with ID %s not found", id)
		return nil, fmt.Errorf("node not found")
	} else if err != nil {
		log.Printf("Error fetching node with ID %s: %v", id, err)
		return nil, fmt.Errorf("failed to fetch node: %v", err)
	}

	if parentID.Valid {
		parentIDStr := parentID.String
		node.ParentID = &parentIDStr
	}

	// Hämta alla barn till denna nod
	rows, err := db.Query(`
		SELECT id, name, parent_id, created_at, updated_at
		FROM nodes
		WHERE parent_id = ?
		ORDER BY name ASC
	`, node.ID)
	if err != nil {
		log.Printf("Error fetching children for node ID %s: %v", node.ID, err)
		return &node, nil // Returnera noden även om vi inte kunde hämta barnen
	}
	defer rows.Close()

	children, err := scanNodeRows(rows)
	if err != nil {
		log.Printf("Error scanning child rows: %v", err)
		return &node, nil // Returnera noden även om vi inte kunde läsa barnen
	}

	node.Children = children
	return &node, nil
}
type nodeResolver struct{ *Resolver }
type fileResolver struct{ *Resolver }
func generateJWT(userID, username string) (string, error) {
	// Create a new JWT token
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		"user_id":  userID,
		"username": username,
		"exp":      time.Now().Add(time.Hour * 24 * 7).Unix(), // Token expires in 7 days
	})

	// Sign the token with the secret key
	// In a production environment, this should be stored securely and not hardcoded
	jwtSecret := []byte("your-256-bit-secret") // Change this to a secure secret in production
	tokenString, err := token.SignedString(jwtSecret)
	if err != nil {
		return "", err
	}

	return tokenString, nil
}
func validateJWT(tokenString string) (jwt.MapClaims, error) {
	// Parse the token
	token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) {
		// Validate the signing method
		if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
			return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
		}

		// Return the secret key
		jwtSecret := []byte("your-256-bit-secret") // Change this to a secure secret in production
		return jwtSecret, nil
	})

	if err != nil {
		return nil, err
	}

	// Check if the token is valid
	if claims, ok := token.Claims.(jwt.MapClaims); ok && token.Valid {
		return claims, nil
	}

	return nil, fmt.Errorf("invalid token")
}
func scanNodeRows(rows *sql.Rows) ([]*model.Node, error) {
	var nodes []*model.Node
	for rows.Next() {
		var node model.Node
		var parentID sql.NullString
		var createdAt, updatedAt string

		if err := rows.Scan(&node.ID, &node.Name, &parentID, &createdAt, &updatedAt); err != nil {
			log.Printf("Error scanning node row: %v", err)
			return nil, fmt.Errorf("failed to scan node row: %v", err)
		}

		node.CreatedAt = createdAt
		node.UpdatedAt = updatedAt
		if parentID.Valid {
			parentIDStr := parentID.String
			node.ParentID = &parentIDStr
		}

		nodes = append(nodes, &node)
	}

	if err := rows.Err(); err != nil {
		log.Printf("Error iterating over node rows: %v", err)
		return nil, fmt.Errorf("failed to iterate over node rows: %v", err)
	}

	return nodes, nil
}
func (r *Resolver) detectCycle(nodeID string, newParentID string, isCycle *bool) error {
	// Om den nya föräldern är samma som noden själv, är det en cykel
	if nodeID == newParentID {
		*isCycle = true
		return nil
	}

	// Kontrollera om den nya föräldern har den aktuella noden som förfader
	var currentParentID sql.NullString
	err := r.DB.QueryRow("SELECT parent_id FROM nodes WHERE id = ?", newParentID).Scan(&currentParentID)
	if err == sql.ErrNoRows {
		// Om föräldern inte finns, är det inget problem
		*isCycle = false
		return nil
	} else if err != nil {
		return err
	}

	// Om förälderns förälder är NULL, är det slutet på kedjan - ingen cykel
	if !currentParentID.Valid {
		*isCycle = false
		return nil
	}

	// Om förälderns förälder är den aktuella noden, är det en cykel
	if currentParentID.String == nodeID {
		*isCycle = true
		return nil
	}

	// Fortsätt rekursivt upp i hierarkin
	return r.detectCycle(nodeID, currentParentID.String, isCycle)
}
*/
