package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.69

import (
	"context"
	"database/sql"
	"encoding/base64"
	"fmt"
	"graphql-backend/graph/model"
	"log"
	"strconv"
	"strings"
	"time"

	_ "github.com/mattn/go-sqlite3"
	"golang.org/x/crypto/bcrypt"
)

// SaveFile är resolvern för saveFile-fältet
// Hanterar uppladdning av nya filer och deras metadata till databasen
func (r *mutationResolver) SaveFile(ctx context.Context, input model.FileInput) (*model.File, error) {
	logAction("Received request to save file")
	log.Printf("Saving file: %s", input.Name)

	// Verifierar att databasanslutningen är aktiv
	if r.DB == nil {
		log.Printf("Database connection is nil")
		return nil, fmt.Errorf("internal server error: database connection is not initialized")
	}

	// Dekodar base64-data till binär form
	fileData, err := base64.StdEncoding.DecodeString(input.FileData)
	if err != nil {
		log.Printf("Error decoding file data: %v", err)
		return nil, fmt.Errorf("invalid file data: %v", err)
	}

	// Default nodeId to 1 (root) if not specified
	nodeID := "1"
	if input.NodeID != nil && *input.NodeID != "" {
		// Verify that the node exists
		var exists bool
		err := r.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM nodes WHERE id = ?)", *input.NodeID).Scan(&exists)
		if err != nil {
			log.Printf("Error checking if node exists: %v", err)
			return nil, fmt.Errorf("failed to validate node: %v", err)
		}
		if !exists {
			log.Printf("Node with ID %s does not exist", *input.NodeID)
			return nil, fmt.Errorf("node not found")
		}
		nodeID = *input.NodeID
	}

	// Sparar filinformation och binär data i databasen
	result, err := r.DB.Exec(
		"INSERT INTO files (name, size, content_type, created_at, file_data, node_id) VALUES (?, ?, ?, datetime('now'), ?, ?)",
		input.Name, input.Size, input.ContentType, fileData, nodeID,
	)
	if err != nil {
		log.Printf("Error saving file to database: %v", err)
		return nil, fmt.Errorf("failed to save file: %v", err)
	}

	fileID, err := result.LastInsertId()
	if err != nil {
		log.Printf("Error retrieving last insert ID: %v", err)
		return nil, fmt.Errorf("failed to retrieve file ID: %v", err)
	}

	log.Printf("File saved to database with ID: %d", fileID)

	// Sparar metadata för filen
	for _, meta := range input.Metadata {
		_, err := r.DB.Exec(
			"INSERT INTO metadata (file_id, key, value) VALUES (?, ?, ?)",
			fileID, meta.Key, meta.Value,
		)
		if err != nil {
			log.Printf("Error saving metadata to database: %v", err)
			return nil, fmt.Errorf("failed to save metadata: %v", err)
		}
	}

	log.Printf("File and metadata saved successfully with ID: %d", fileID)

	// Konverterar metadata till rätt format för responsen
	metadata := make([]*model.Metadata, len(input.Metadata))
	for i, meta := range input.Metadata {
		metadata[i] = &model.Metadata{
			Key:   meta.Key,
			Value: meta.Value,
		}
	}

	// Convert nodeID to string pointer
	nodeIDStr := nodeID

	return &model.File{
		ID:          fmt.Sprintf("%d", fileID),
		Name:        input.Name,
		Size:        input.Size,
		ContentType: input.ContentType,
		CreatedAt:   time.Now().Format(time.RFC3339),
		FileData:    &input.FileData, // Skickar tillbaka base64-kodad data
		Metadata:    metadata,
		NodeID:      &nodeIDStr,
	}, nil
}

// deleteFile är resolvern för deleteFile-mutation
func (r *mutationResolver) DeleteFile(ctx context.Context, id string) (bool, error) {
	logAction(fmt.Sprintf("Attempting to delete file with ID: %s", id))

	if r.DB == nil {
		log.Printf("Database connection is nil")
		return false, fmt.Errorf("internal server error: database connection is not initialized")
	}

	// Ta bort filen och dess metadata från databasen
	result, err := r.DB.Exec("DELETE FROM files WHERE id = ?", id)
	if err != nil {
		log.Printf("Error deleting file with ID %s: %v", id, err)
		return false, fmt.Errorf("failed to delete file: %v", err)
	}

	affectedRows, err := result.RowsAffected()
	if err != nil {
		log.Printf("Error fetching affected rows for file ID %s: %v", id, err)
		return false, fmt.Errorf("failed to verify deletion: %v", err)
	}

	if affectedRows == 0 {
		log.Printf("No file found with ID: %s", id)
		return false, fmt.Errorf("file not found")
	}

	log.Printf("Successfully deleted file with ID: %s", id)
	return true, nil
}

// UpdateMetadata är resolvern för updateMetadata-mutation
// Uppdaterar metadata för en fil
func (r *mutationResolver) UpdateMetadata(ctx context.Context, fileID string, metadataInput []*model.MetadataInput) (*model.File, error) {
	logAction(fmt.Sprintf("Attempting to update metadata for file with ID: %s", fileID))

	if r.DB == nil {
		log.Printf("Database connection is nil")
		return nil, fmt.Errorf("internal server error: database connection is not initialized")
	}

	// Kontrollera att filen finns
	var exists bool
	err := r.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM files WHERE id = ?)", fileID).Scan(&exists)
	if err != nil {
		log.Printf("Error checking if file exists: %v", err)
		return nil, fmt.Errorf("failed to check if file exists: %v", err)
	}

	if !exists {
		log.Printf("No file found with ID: %s", fileID)
		return nil, fmt.Errorf("file not found")
	}

	// Starta en transaktion för att säkerställa att alla operationer lyckas eller misslyckas tillsammans
	tx, err := r.DB.Begin()
	if err != nil {
		log.Printf("Error starting transaction: %v", err)
		return nil, fmt.Errorf("failed to start transaction: %v", err)
	}
	defer func() {
		if err != nil {
			tx.Rollback()
		}
	}()

	// Ta bort befintlig metadata för filen
	_, err = tx.Exec("DELETE FROM metadata WHERE file_id = ?", fileID)
	if err != nil {
		log.Printf("Error deleting existing metadata: %v", err)
		return nil, fmt.Errorf("failed to delete existing metadata: %v", err)
	}

	// Lägg till ny metadata
	for _, meta := range metadataInput {
		_, err := tx.Exec(
			"INSERT INTO metadata (file_id, key, value) VALUES (?, ?, ?)",
			fileID, meta.Key, meta.Value,
		)
		if err != nil {
			log.Printf("Error inserting metadata: %v", err)
			return nil, fmt.Errorf("failed to insert metadata: %v", err)
		}
	}

	// Commit transaktionen
	if err = tx.Commit(); err != nil {
		log.Printf("Error committing transaction: %v", err)
		return nil, fmt.Errorf("failed to commit transaction: %v", err)
	}

	log.Printf("Successfully updated metadata for file with ID: %s", fileID)

	// Hämta den uppdaterade filen för att returnera
	return (&queryResolver{r.Resolver}).GetFile(ctx, fileID)
}

// DeleteMetadata är resolvern för deleteMetadata-mutation
// Tar bort specifik metadata från en fil baserat på nycklar
func (r *mutationResolver) DeleteMetadata(ctx context.Context, fileID string, keys []string) (*model.File, error) {
	logAction(fmt.Sprintf("Attempting to delete metadata for file with ID: %s", fileID))

	if r.DB == nil {
		log.Printf("Database connection is nil")
		return nil, fmt.Errorf("internal server error: database connection is not initialized")
	}

	// Kontrollera att filen finns
	var exists bool
	err := r.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM files WHERE id = ?)", fileID).Scan(&exists)
	if err != nil {
		log.Printf("Error checking if file exists: %v", err)
		return nil, fmt.Errorf("failed to check if file exists: %v", err)
	}

	if !exists {
		log.Printf("No file found with ID: %s", fileID)
		return nil, fmt.Errorf("file not found")
	}

	// Starta en transaktion
	tx, err := r.DB.Begin()
	if err != nil {
		log.Printf("Error starting transaction: %v", err)
		return nil, fmt.Errorf("failed to start transaction: %v", err)
	}
	defer func() {
		if err != nil {
			tx.Rollback()
		}
	}()

	// Ta bort metadata baserat på nycklar
	for _, key := range keys {
		_, err := tx.Exec("DELETE FROM metadata WHERE file_id = ? AND key = ?", fileID, key)
		if err != nil {
			log.Printf("Error deleting metadata with key %s: %v", key, err)
			return nil, fmt.Errorf("failed to delete metadata: %v", err)
		}
	}

	// Commit transaktionen
	if err = tx.Commit(); err != nil {
		log.Printf("Error committing transaction: %v", err)
		return nil, fmt.Errorf("failed to commit transaction: %v", err)
	}

	log.Printf("Successfully deleted metadata for file with ID: %s", fileID)

	// Hämta den uppdaterade filen för att returnera
	return (&queryResolver{r.Resolver}).GetFile(ctx, fileID)
}

// MoveFile moves a file to a different node
func (r *mutationResolver) MoveFile(ctx context.Context, fileID string, nodeID string) (*model.File, error) {
	logAction(fmt.Sprintf("Moving file %s to node %s", fileID, nodeID))

	// Verify the file exists
	var fileExists bool
	err := r.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM files WHERE id = ?)", fileID).Scan(&fileExists)
	if err != nil {
		log.Printf("Error checking if file exists: %v", err)
		return nil, fmt.Errorf("failed to verify file: %v", err)
	}
	if !fileExists {
		log.Printf("File with ID %s does not exist", fileID)
		return nil, fmt.Errorf("file not found")
	}

	// Verify the node exists
	var nodeExists bool
	err = r.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM nodes WHERE id = ?)", nodeID).Scan(&nodeExists)
	if err != nil {
		log.Printf("Error checking if node exists: %v", err)
		return nil, fmt.Errorf("failed to verify node: %v", err)
	}
	if !nodeExists {
		log.Printf("Node with ID %s does not exist", nodeID)
		return nil, fmt.Errorf("node not found")
	}

	// Update the file's node_id
	_, err = r.DB.Exec("UPDATE files SET node_id = ? WHERE id = ?", nodeID, fileID)
	if err != nil {
		log.Printf("Error updating file node_id: %v", err)
		return nil, fmt.Errorf("failed to update file: %v", err)
	}

	// Get the updated file with all necessary information
	var file model.File
	var createdAt string

	err = r.DB.QueryRow(`
		SELECT id, name, size, content_type, created_at
		FROM files WHERE id = ?`, fileID).Scan(
		&file.ID, &file.Name, &file.Size, &file.ContentType, &createdAt)

	if err != nil {
		log.Printf("Error fetching updated file data: %v", err)
		return nil, fmt.Errorf("file updated but failed to retrieve updated data: %v", err)
	}

	file.CreatedAt = createdAt
	file.NodeID = &nodeID

	// Fetch metadata for the file
	metaRows, err := r.DB.Query("SELECT key, value FROM metadata WHERE file_id = ?", fileID)
	if err != nil {
		log.Printf("Error fetching metadata for file ID %s: %v", fileID, err)
		return nil, fmt.Errorf("failed to fetch metadata: %v", err)
	}
	defer metaRows.Close()

	var metadata []*model.Metadata
	for metaRows.Next() {
		var meta model.Metadata
		if err := metaRows.Scan(&meta.Key, &meta.Value); err != nil {
			log.Printf("Error scanning metadata row: %v", err)
			return nil, fmt.Errorf("failed to scan metadata row: %v", err)
		}
		metadata = append(metadata, &meta)
	}
	file.Metadata = metadata

	// Fetch the node data so the file has a reference to its node
	node, err := getNodeById(ctx, r.DB, nodeID)
	if err != nil {
		log.Printf("Warning: Failed to fetch node data for the file: %v", err)
		// Continue without the node data as it's not critical
	} else {
		file.Node = node
	}

	log.Printf("Successfully moved file ID %s to node ID %s", fileID, nodeID)
	return &file, nil
}

// CreateNode är resolvern för createNode-mutation
// Skapar en ny nod med ett valfritt parent ID
func (r *mutationResolver) CreateNode(ctx context.Context, input model.NodeInput) (*model.Node, error) {
	logAction(fmt.Sprintf("Attempting to create node with name: %s", input.Name))

	if r.DB == nil {
		log.Printf("Database connection is nil")
		return nil, fmt.Errorf("internal server error: database connection is not initialized")
	}

	// Validera parent_id om det är angivet
	if input.ParentID != nil {
		var exists bool
		err := r.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM nodes WHERE id = ?)", *input.ParentID).Scan(&exists)
		if err != nil {
			log.Printf("Error checking if parent node exists: %v", err)
			return nil, fmt.Errorf("failed to check if parent node exists: %v", err)
		}

		if !exists {
			log.Printf("Parent node with ID %s does not exist", *input.ParentID)
			return nil, fmt.Errorf("parent node not found")
		}
	}

	// Skapa den nya noden
	now := time.Now().Format(time.RFC3339)
	var result sql.Result
	var err error

	if input.ParentID != nil {
		result, err = r.DB.Exec(
			"INSERT INTO nodes (name, parent_id, created_at, updated_at) VALUES (?, ?, ?, ?)",
			input.Name, input.ParentID, now, now,
		)
	} else {
		result, err = r.DB.Exec(
			"INSERT INTO nodes (name, created_at, updated_at) VALUES (?, ?, ?)",
			input.Name, now, now,
		)
	}

	if err != nil {
		log.Printf("Error creating node: %v", err)
		return nil, fmt.Errorf("failed to create node: %v", err)
	}

	nodeID, err := result.LastInsertId()
	if err != nil {
		log.Printf("Error retrieving last insert ID: %v", err)
		return nil, fmt.Errorf("failed to retrieve node ID: %v", err)
	}

	log.Printf("Node created successfully with ID: %d", nodeID)

	// Returnera den skapade noden
	node := &model.Node{
		ID:        fmt.Sprintf("%d", nodeID),
		Name:      input.Name,
		CreatedAt: now,
		UpdatedAt: now,
	}

	if input.ParentID != nil {
		node.ParentID = input.ParentID
	}

	return node, nil
}

// UpdateNode är resolvern för updateNode-mutation
// Uppdaterar en befintlig nod med nytt namn och/eller parent ID
func (r *mutationResolver) UpdateNode(ctx context.Context, id string, input model.NodeUpdateInput) (*model.Node, error) {
	logAction(fmt.Sprintf("Attempting to update node with ID: %s", id))

	if r.DB == nil {
		log.Printf("Database connection is nil")
		return nil, fmt.Errorf("internal server error: database connection is not initialized")
	}

	// Kontrollera att noden finns
	var exists bool
	err := r.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM nodes WHERE id = ?)", id).Scan(&exists)
	if err != nil {
		log.Printf("Error checking if node exists: %v", err)
		return nil, fmt.Errorf("failed to check if node exists: %v", err)
	}

	if !exists {
		log.Printf("Node with ID %s does not exist", id)
		return nil, fmt.Errorf("node not found")
	}

	// Om parentId är uppdaterat, kontrollera att den nya föräldern existerar
	if input.ParentID != nil {
		// Kontrollera om den nya föräldern finns
		var parentExists bool
		err := r.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM nodes WHERE id = ?)", *input.ParentID).Scan(&parentExists)
		if err != nil {
			log.Printf("Error checking if parent node exists: %v", err)
			return nil, fmt.Errorf("failed to check if parent node exists: %v", err)
		}

		if !parentExists {
			log.Printf("Parent node with ID %s does not exist", *input.ParentID)
			return nil, fmt.Errorf("parent node not found")
		}

		// Kontrollera att den nya föräldern inte är en av barnens barn (cykeldetektion)
		var isCycle bool
		err = r.detectCycle(id, *input.ParentID, &isCycle)
		if err != nil {
			log.Printf("Error detecting cycle: %v", err)
			return nil, fmt.Errorf("failed to validate hierarchy: %v", err)
		}

		if isCycle {
			log.Printf("Cannot update node: would create a cycle in the hierarchy")
			return nil, fmt.Errorf("cannot update node: would create a cycle in the hierarchy")
		}
	}

	// Bygga update query dynamiskt baserat på vilka fält som ska uppdateras
	query := "UPDATE nodes SET updated_at = datetime('now')"
	args := []interface{}{}

	if input.Name != nil {
		query += ", name = ?"
		args = append(args, *input.Name)
	}

	if input.ParentID != nil {
		query += ", parent_id = ?"
		args = append(args, *input.ParentID)
	} else if input.ParentID == nil {
		// Om parent_id explicit sätts till null
		query += ", parent_id = NULL"
	}

	query += " WHERE id = ?"
	args = append(args, id)

	// Utför uppdateringen
	_, err = r.DB.Exec(query, args...)
	if err != nil {
		log.Printf("Error updating node: %v", err)
		return nil, fmt.Errorf("failed to update node: %v", err)
	}

	log.Printf("Node with ID %s updated successfully", id)

	// Hämta den uppdaterade noden från databasen
	return getNodeById(ctx, r.DB, id)
}

// DeleteNode är resolvern för deleteNode-mutation
// Tar bort en nod om den inte har några barn
func (r *mutationResolver) DeleteNode(ctx context.Context, id string) (bool, error) {
	logAction(fmt.Sprintf("Attempting to delete node with ID: %s", id))

	if r.DB == nil {
		log.Printf("Database connection is nil")
		return false, fmt.Errorf("internal server error: database connection is not initialized")
	}

	// Kontrollera att noden finns
	var exists bool
	err := r.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM nodes WHERE id = ?)", id).Scan(&exists)
	if err != nil {
		log.Printf("Error checking if node exists: %v", err)
		return false, fmt.Errorf("failed to check if node exists: %v", err)
	}

	if !exists {
		log.Printf("Node with ID %s does not exist", id)
		return false, fmt.Errorf("node not found")
	}

	// Kontrollera om noden har barn
	var hasChildren bool
	err = r.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM nodes WHERE parent_id = ?)", id).Scan(&hasChildren)
	if err != nil {
		log.Printf("Error checking if node has children: %v", err)
		return false, fmt.Errorf("failed to check if node has children: %v", err)
	}

	if hasChildren {
		log.Printf("Cannot delete node with ID %s: has children nodes", id)
		return false, fmt.Errorf("cannot delete node: has children nodes")
	}

	// Ta bort noden
	result, err := r.DB.Exec("DELETE FROM nodes WHERE id = ?", id)
	if err != nil {
		log.Printf("Error deleting node with ID %s: %v", id, err)
		return false, fmt.Errorf("failed to delete node: %v", err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		log.Printf("Error getting rows affected: %v", err)
		return false, fmt.Errorf("error confirming deletion: %v", err)
	}

	if rowsAffected == 0 {
		log.Printf("No rows deleted for node with ID %s", id)
		return false, nil
	}

	log.Printf("Node with ID %s deleted successfully", id)
	return true, nil
}

// MoveNode moves a node to a new parent
func (r *mutationResolver) MoveNode(ctx context.Context, id string, newParentID string) (*model.Node, error) {
	logAction(fmt.Sprintf("Moving node %s to new parent %s", id, newParentID))

	// Check if user has permission to modify this node
	hasPermission, err := checkPermission(ctx, r.DB, id, PERM_MODIFY)
	if err != nil {
		return nil, err
	}

	if !hasPermission {
		return nil, fmt.Errorf("permission denied: cannot modify this node")
	}

	// Check if user has permission to modify the new parent node
	hasPermission, err = checkPermission(ctx, r.DB, newParentID, PERM_MODIFY)
	if err != nil {
		return nil, err
	}

	if !hasPermission {
		return nil, fmt.Errorf("permission denied: cannot modify the target node")
	}

	// Check if the new parent node exists
	var parentExists bool
	err = r.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM nodes WHERE id = ?)", newParentID).Scan(&parentExists)
	if err != nil {
		log.Printf("Error checking if parent node exists: %v", err)
		return nil, fmt.Errorf("failed to check if parent node exists: %v", err)
	}

	if !parentExists {
		log.Printf("Parent node with ID %s does not exist", newParentID)
		return nil, fmt.Errorf("parent node not found")
	}

	// Check for cycles
	var isCycle bool
	err = r.detectCycle(id, newParentID, &isCycle)
	if err != nil {
		log.Printf("Error detecting cycle: %v", err)
		return nil, fmt.Errorf("failed to validate hierarchy: %v", err)
	}

	if isCycle {
		log.Printf("Cannot update node: would create a cycle in the hierarchy")
		return nil, fmt.Errorf("cannot update node: would create a cycle in the hierarchy")
	}

	// Update the node's parent
	_, err = r.DB.Exec("UPDATE nodes SET parent_id = ? WHERE id = ?", newParentID, id)
	if err != nil {
		log.Printf("Error updating node parent: %v", err)
		return nil, fmt.Errorf("failed to update node parent: %v", err)
	}

	// Get the updated node
	return getNodeWithPermissions(ctx, r.DB, id)
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, username string, password string) (*model.AuthPayload, error) {
	logAction(fmt.Sprintf("Login attempt for user: %s", username))

	if r.DB == nil {
		log.Printf("Database connection is nil")
		return nil, fmt.Errorf("internal server error: database connection is not initialized")
	}

	// Query the database for the user with the provided username
	var id string
	var passwordHash string
	var name string
	err := r.DB.QueryRow("SELECT id, password_hash, name FROM users WHERE username = ?", username).Scan(&id, &passwordHash, &name)

	// Check if user exists
	if err == sql.ErrNoRows {
		log.Printf("User not found: %s", username)
		return nil, fmt.Errorf("invalid username or password")
	} else if err != nil {
		log.Printf("Error querying user: %v", err)
		return nil, fmt.Errorf("internal server error: %v", err)
	}

	// Compare the provided password with the stored hash
	err = bcrypt.CompareHashAndPassword([]byte(passwordHash), []byte(password))
	if err != nil {
		log.Printf("Invalid password for user: %s", username)
		return nil, fmt.Errorf("invalid username or password")
	}

	// Generate JWT token
	token, err := generateJWT(id, username)
	if err != nil {
		log.Printf("Error generating JWT token: %v", err)
		return nil, fmt.Errorf("internal server error: %v", err)
	}

	// Return the auth payload
	return &model.AuthPayload{
		Token: token,
		User: &model.User{
			ID:       id,
			Name:     name,
			Username: username,
		},
	}, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context, token string) (bool, error) {
	logAction("Logout request received")

	// Parse and validate the token first to ensure it's a valid token
	_, err := validateJWT(token)
	if err != nil {
		// If token is already invalid, we consider logout successful
		if err.Error() == "token has been invalidated" {
			return true, nil
		}
		log.Printf("Error validating token during logout: %v", err)
		return false, fmt.Errorf("invalid token")
	}

	// Add the token to the blacklist
	BlacklistToken(token)
	log.Printf("Successfully invalidated token")

	return true, nil
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, username string, password string) (*model.AuthPayload, error) {
	logAction(fmt.Sprintf("Registration attempt for user: %s", username))

	if r.DB == nil {
		log.Printf("Database connection is nil")
		return nil, fmt.Errorf("internal server error: database connection is not initialized")
	}

	// Check if username already exists
	var exists bool
	err := r.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM users WHERE username = ?)", username).Scan(&exists)
	if err != nil {
		log.Printf("Error checking if user exists: %v", err)
		return nil, fmt.Errorf("internal server error: %v", err)
	}

	if exists {
		log.Printf("Username already taken: %s", username)
		return nil, fmt.Errorf("username already taken")
	}

	// Hash the password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		log.Printf("Error hashing password: %v", err)
		return nil, fmt.Errorf("internal server error: %v", err)
	}

	// Start a transaction
	tx, err := r.DB.Begin()
	if err != nil {
		log.Printf("Error starting transaction: %v", err)
		return nil, fmt.Errorf("internal server error: %v", err)
	}
	defer func() {
		if err != nil {
			tx.Rollback()
		}
	}()

	// Insert the new user (use username as name)
	result, err := tx.Exec(
		"INSERT INTO users (username, name, password_hash, created_at) VALUES (?, ?, ?, datetime('now'))",
		username, username, string(hashedPassword),
	)
	if err != nil {
		log.Printf("Error inserting user: %v", err)
		return nil, fmt.Errorf("internal server error: %v", err)
	}

	// Get the user ID
	userID, err := result.LastInsertId()
	if err != nil {
		log.Printf("Error retrieving user ID: %v", err)
		return nil, fmt.Errorf("internal server error: %v", err)
	}

	// Commit the transaction
	if err = tx.Commit(); err != nil {
		log.Printf("Error committing transaction: %v", err)
		return nil, fmt.Errorf("internal server error: %v", err)
	}

	// Generate JWT token
	token, err := generateJWT(fmt.Sprintf("%d", userID), username)
	if err != nil {
		log.Printf("Error generating JWT token: %v", err)
		return nil, fmt.Errorf("internal server error: %v", err)
	}

	log.Printf("User registered successfully: %s", username)

	// Return the auth payload
	return &model.AuthPayload{
		Token: token,
		User: &model.User{
			ID:       fmt.Sprintf("%d", userID),
			Name:     username,
			Username: username,
		},
	}, nil
}

// UpdatePassword is the resolver for the updatePassword field.
func (r *mutationResolver) UpdatePassword(ctx context.Context, currentPassword string, newPassword string) (bool, error) {
	logAction("Attempting to update password")

	// Get authorization token from context
	authToken, ok := ctx.Value("Authorization").(string)
	if !ok || authToken == "" {
		log.Printf("No authorization token found in context")
		return false, fmt.Errorf("unauthorized: missing token")
	}

	// Remove "Bearer " prefix if present
	authToken = strings.TrimPrefix(authToken, "Bearer ")

	// Get user claims from JWT token
	claims, err := validateJWT(authToken)
	if err != nil {
		log.Printf("Invalid token: %v", err)
		return false, fmt.Errorf("unauthorized: invalid token")
	}

	// Get user ID from claims
	userID, ok := claims["user_id"].(string)
	if !ok {
		log.Printf("User ID not found in token claims")
		return false, fmt.Errorf("unauthorized: invalid token claims")
	}

	// Verify current password
	var storedHash string
	err = r.DB.QueryRow("SELECT password_hash FROM users WHERE id = ?", userID).Scan(&storedHash)
	if err != nil {
		log.Printf("Error fetching user password hash: %v", err)
		return false, fmt.Errorf("internal server error")
	}

	// Compare current password with stored hash
	if err := bcrypt.CompareHashAndPassword([]byte(storedHash), []byte(currentPassword)); err != nil {
		log.Printf("Invalid current password for user ID %s: %v", userID, err)
		return false, fmt.Errorf("invalid current password")
	}

	// Hash the new password
	newHash, err := bcrypt.GenerateFromPassword([]byte(newPassword), bcrypt.DefaultCost)
	if err != nil {
		log.Printf("Error hashing new password: %v", err)
		return false, fmt.Errorf("internal server error")
	}

	// Update the password in the database
	_, err = r.DB.Exec("UPDATE users SET password_hash = ? WHERE id = ?", string(newHash), userID)
	if err != nil {
		log.Printf("Error updating password: %v", err)
		return false, fmt.Errorf("failed to update password")
	}

	log.Printf("Successfully updated password for user ID: %s", userID)
	return true, nil
}

// saveUserSetting is the resolver for the saveUserSetting field
func (r *mutationResolver) SaveUserSetting(ctx context.Context, key string, value string) (*model.UserSetting, error) {
	logAction(fmt.Sprintf("Saving user setting: %s = %s", key, value))

	// Get user ID from JWT token
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// Get current time for timestamps
	now := time.Now().Format(time.RFC3339)

	// Try to insert or update the setting using UPSERT pattern
	result, err := r.DB.Exec(`
		INSERT INTO user_settings (user_id, key, value, created_at, updated_at) 
		VALUES (?, ?, ?, ?, ?)
		ON CONFLICT(user_id, key) DO UPDATE SET
		value = ?,
		updated_at = ?
	`, userID, key, value, now, now, value, now)

	if err != nil {
		log.Printf("Error saving user setting: %v", err)
		return nil, fmt.Errorf("failed to save user setting: %v", err)
	}

	// Get the ID of the inserted/updated setting
	var settingID int64
	if lastInsertID, err := result.LastInsertId(); err == nil && lastInsertID > 0 {
		// If this was a new insert
		settingID = lastInsertID
	} else {
		// If this was an update, query for the ID
		err = r.DB.QueryRow("SELECT id FROM user_settings WHERE user_id = ? AND key = ?", userID, key).Scan(&settingID)
		if err != nil {
			log.Printf("Error retrieving setting ID: %v", err)
			return nil, fmt.Errorf("setting was saved but failed to retrieve ID: %v", err)
		}
	}

	return &model.UserSetting{
		ID:        fmt.Sprintf("%d", settingID),
		Key:       key,
		Value:     value,
		CreatedAt: now,
		UpdatedAt: now,
	}, nil
}

// deleteUserSetting is the resolver for the deleteUserSetting field
func (r *mutationResolver) DeleteUserSetting(ctx context.Context, key string) (bool, error) {
	logAction(fmt.Sprintf("Deleting user setting with key: %s", key))

	// Get user ID from JWT token
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return false, err
	}

	// Delete the setting
	result, err := r.DB.Exec("DELETE FROM user_settings WHERE user_id = ? AND key = ?", userID, key)
	if err != nil {
		log.Printf("Error deleting user setting: %v", err)
		return false, fmt.Errorf("failed to delete user setting: %v", err)
	}

	// Check if any rows were affected
	rowsAffected, err := result.RowsAffected()
	if err != nil {
		log.Printf("Error checking rows affected: %v", err)
		return false, fmt.Errorf("error confirming deletion: %v", err)
	}

	return rowsAffected > 0, nil
}

// CreateGroup creates a new group
func (r *mutationResolver) CreateGroup(ctx context.Context, name string) (*model.Group, error) {
	logAction(fmt.Sprintf("Creating group with name: %s", name))

	// Only administrators can create groups
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// Check if the user is an administrator
	var isAdmin bool
	err = r.DB.QueryRow(`
		SELECT EXISTS(
			SELECT 1 
			FROM group_members gm
			JOIN groups g ON gm.group_id = g.id
			WHERE gm.user_id = ? AND g.name = 'Administrators'
		)
	`, userID).Scan(&isAdmin)

	if err != nil {
		log.Printf("Error checking admin status: %v", err)
		return nil, fmt.Errorf("failed to check administrator status: %v", err)
	}

	if !isAdmin {
		return nil, fmt.Errorf("permission denied: must be an administrator to create groups")
	}

	// Check if group name already exists
	var exists bool
	err = r.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM groups WHERE name = ?)", name).Scan(&exists)
	if err != nil {
		log.Printf("Error checking if group exists: %v", err)
		return nil, fmt.Errorf("failed to check if group exists: %v", err)
	}

	if exists {
		return nil, fmt.Errorf("group name already exists")
	}

	// Create the group
	result, err := r.DB.Exec(
		"INSERT INTO groups (name, created_at) VALUES (?, datetime('now'))",
		name,
	)
	if err != nil {
		log.Printf("Error creating group: %v", err)
		return nil, fmt.Errorf("failed to create group: %v", err)
	}

	groupID, err := result.LastInsertId()
	if err != nil {
		log.Printf("Error retrieving last insert ID: %v", err)
		return nil, fmt.Errorf("failed to retrieve group ID: %v", err)
	}

	return &model.Group{
		ID:   fmt.Sprintf("%d", groupID),
		Name: name,
	}, nil
}

// UpdateGroup updates an existing group
func (r *mutationResolver) UpdateGroup(ctx context.Context, id string, name string) (*model.Group, error) {
	logAction(fmt.Sprintf("Updating group with ID: %s", id))

	// Only administrators can update groups
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// Check if the user is an administrator
	var isAdmin bool
	err = r.DB.QueryRow(`
		SELECT EXISTS(
			SELECT 1 
			FROM group_members gm
			JOIN groups g ON gm.group_id = g.id
			WHERE gm.user_id = ? AND g.name = 'Administrators'
		)
	`, userID).Scan(&isAdmin)

	if err != nil {
		log.Printf("Error checking admin status: %v", err)
		return nil, fmt.Errorf("failed to check administrator status: %v", err)
	}

	if !isAdmin {
		return nil, fmt.Errorf("permission denied: must be an administrator to update groups")
	}

	// Check if group exists
	var exists bool
	err = r.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM groups WHERE id = ?)", id).Scan(&exists)
	if err != nil {
		log.Printf("Error checking if group exists: %v", err)
		return nil, fmt.Errorf("failed to check if group exists: %v", err)
	}

	if !exists {
		return nil, fmt.Errorf("group not found")
	}

	// Check if this is the Administrators group - don't allow renaming it
	var currentName string
	err = r.DB.QueryRow("SELECT name FROM groups WHERE id = ?", id).Scan(&currentName)
	if err != nil {
		log.Printf("Error fetching group name: %v", err)
		return nil, fmt.Errorf("failed to fetch group name: %v", err)
	}

	if currentName == "Administrators" {
		return nil, fmt.Errorf("cannot rename the Administrators group")
	}

	// Check if new name already exists
	var nameExists bool
	err = r.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM groups WHERE name = ? AND id != ?)", name, id).Scan(&nameExists)
	if err != nil {
		log.Printf("Error checking if group name exists: %v", err)
		return nil, fmt.Errorf("failed to check if group name exists: %v", err)
	}

	if nameExists {
		return nil, fmt.Errorf("group name already exists")
	}

	// Update the group
	_, err = r.DB.Exec(
		"UPDATE groups SET name = ? WHERE id = ?",
		name, id,
	)
	if err != nil {
		log.Printf("Error updating group: %v", err)
		return nil, fmt.Errorf("failed to update group: %v", err)
	}

	return &model.Group{
		ID:   id,
		Name: name,
	}, nil
}

// DeleteGroup deletes a group
func (r *mutationResolver) DeleteGroup(ctx context.Context, id string) (bool, error) {
	logAction(fmt.Sprintf("Deleting group with ID: %s", id))

	// Only administrators can delete groups
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return false, err
	}

	// Check if the user is an administrator
	var isAdmin bool
	err = r.DB.QueryRow(`
		SELECT EXISTS(
			SELECT 1 
			FROM group_members gm
			JOIN groups g ON gm.group_id = g.id
			WHERE gm.user_id = ? AND g.name = 'Administrators'
		)
	`, userID).Scan(&isAdmin)

	if err != nil {
		log.Printf("Error checking admin status: %v", err)
		return false, fmt.Errorf("failed to check administrator status: %v", err)
	}

	if !isAdmin {
		return false, fmt.Errorf("permission denied: must be an administrator to delete groups")
	}

	// Check if group exists
	var exists bool
	err = r.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM groups WHERE id = ?)", id).Scan(&exists)
	if err != nil {
		log.Printf("Error checking if group exists: %v", err)
		return false, fmt.Errorf("failed to check if group exists: %v", err)
	}

	if !exists {
		return false, fmt.Errorf("group not found")
	}

	// Check if this is the Administrators group - don't allow deleting it
	var groupName string
	err = r.DB.QueryRow("SELECT name FROM groups WHERE id = ?", id).Scan(&groupName)
	if err != nil {
		log.Printf("Error fetching group name: %v", err)
		return false, fmt.Errorf("failed to fetch group name: %v", err)
	}

	if groupName == "Administrators" {
		return false, fmt.Errorf("cannot delete the Administrators group")
	}

	// Remove all members from the group and then delete it
	tx, err := r.DB.Begin()
	if err != nil {
		log.Printf("Error starting transaction: %v", err)
		return false, fmt.Errorf("failed to start transaction: %v", err)
	}
	defer func() {
		if err != nil {
			tx.Rollback()
		}
	}()

	// Delete group memberships
	_, err = tx.Exec("DELETE FROM group_members WHERE group_id = ?", id)
	if err != nil {
		log.Printf("Error deleting group memberships: %v", err)
		return false, fmt.Errorf("failed to delete group memberships: %v", err)
	}

	// Delete group
	result, err := tx.Exec("DELETE FROM groups WHERE id = ?", id)
	if err != nil {
		log.Printf("Error deleting group: %v", err)
		return false, fmt.Errorf("failed to delete group: %v", err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		log.Printf("Error getting rows affected: %v", err)
		tx.Rollback()
		return false, fmt.Errorf("error confirming deletion: %v", err)
	}

	if rowsAffected == 0 {
		tx.Rollback()
		return false, fmt.Errorf("group not found")
	}

	// Commit the transaction
	if err = tx.Commit(); err != nil {
		log.Printf("Error committing transaction: %v", err)
		return false, fmt.Errorf("failed to commit transaction: %v", err)
	}

	return true, nil
}

// AddUserToGroup adds a user to a group
func (r *mutationResolver) AddUserToGroup(ctx context.Context, userID string, groupID string) (bool, error) {
	logAction(fmt.Sprintf("Adding user %s to group %s", userID, groupID))

	// Only administrators can manage group memberships
	currentUserID, err := getUserIDFromContext(ctx)
	if err != nil {
		return false, err
	}

	// Check if the user is an administrator
	var isAdmin bool
	err = r.DB.QueryRow(`
		SELECT EXISTS(
			SELECT 1 
			FROM group_members gm
			JOIN groups g ON gm.group_id = g.id
			WHERE gm.user_id = ? AND g.name = 'Administrators'
		)
	`, currentUserID).Scan(&isAdmin)

	if err != nil {
		log.Printf("Error checking admin status: %v", err)
		return false, fmt.Errorf("failed to check administrator status: %v", err)
	}

	if !isAdmin {
		return false, fmt.Errorf("permission denied: must be an administrator to manage group memberships")
	}

	// Check if user and group exist
	var userExists bool
	err = r.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM users WHERE id = ?)", userID).Scan(&userExists)
	if err != nil {
		log.Printf("Error checking if user exists: %v", err)
		return false, fmt.Errorf("failed to check if user exists: %v", err)
	}

	if !userExists {
		return false, fmt.Errorf("user not found")
	}

	var groupExists bool
	err = r.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM groups WHERE id = ?)", groupID).Scan(&groupExists)
	if err != nil {
		log.Printf("Error checking if group exists: %v", err)
		return false, fmt.Errorf("failed to check if group exists: %v", err)
	}

	if !groupExists {
		return false, fmt.Errorf("group not found")
	}

	// Check if user is already in the group
	var memberExists bool
	err = r.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM group_members WHERE user_id = ? AND group_id = ?)", userID, groupID).Scan(&memberExists)
	if err != nil {
		log.Printf("Error checking if membership exists: %v", err)
		return false, fmt.Errorf("failed to check if membership exists: %v", err)
	}

	if memberExists {
		// User is already in the group, consider this a success
		return true, nil
	}

	// Add user to group
	_, err = r.DB.Exec(
		"INSERT INTO group_members (user_id, group_id, created_at) VALUES (?, ?, datetime('now'))",
		userID, groupID,
	)
	if err != nil {
		log.Printf("Error adding user to group: %v", err)
		return false, fmt.Errorf("failed to add user to group: %v", err)
	}

	return true, nil
}

// RemoveUserFromGroup removes a user from a group
func (r *mutationResolver) RemoveUserFromGroup(ctx context.Context, userID string, groupID string) (bool, error) {
	logAction(fmt.Sprintf("Removing user %s from group %s", userID, groupID))

	// Only administrators can manage group memberships
	currentUserID, err := getUserIDFromContext(ctx)
	if err != nil {
		return false, err
	}

	// Check if the user is an administrator
	var isAdmin bool
	err = r.DB.QueryRow(`
		SELECT EXISTS(
			SELECT 1 
			FROM group_members gm
			JOIN groups g ON gm.group_id = g.id
			WHERE gm.user_id = ? AND g.name = 'Administrators'
		)
	`, currentUserID).Scan(&isAdmin)

	if err != nil {
		log.Printf("Error checking admin status: %v", err)
		return false, fmt.Errorf("failed to check administrator status: %v", err)
	}

	if !isAdmin {
		return false, fmt.Errorf("permission denied: must be an administrator to manage group memberships")
	}

	// Special check: if this is the Administrators group, make sure we're not removing the last admin
	var groupName string
	err = r.DB.QueryRow("SELECT name FROM groups WHERE id = ?", groupID).Scan(&groupName)
	if err != nil {
		log.Printf("Error fetching group name: %v", err)
		return false, fmt.Errorf("failed to fetch group name: %v", err)
	}

	if groupName == "Administrators" {
		// Count admins
		var adminCount int
		err = r.DB.QueryRow("SELECT COUNT(*) FROM group_members WHERE group_id = ?", groupID).Scan(&adminCount)
		if err != nil {
			log.Printf("Error counting administrators: %v", err)
			return false, fmt.Errorf("failed to count administrators: %v", err)
		}

		if adminCount <= 1 {
			// Check if this is the last admin
			var isLastAdmin bool
			err = r.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM group_members WHERE group_id = ? AND user_id = ?)", groupID, userID).Scan(&isLastAdmin)
			if err != nil {
				log.Printf("Error checking if user is admin: %v", err)
				return false, fmt.Errorf("failed to check if user is admin: %v", err)
			}

			if isLastAdmin {
				return false, fmt.Errorf("cannot remove the last administrator")
			}
		}
	}

	// Remove user from group
	result, err := r.DB.Exec(
		"DELETE FROM group_members WHERE user_id = ? AND group_id = ?",
		userID, groupID,
	)
	if err != nil {
		log.Printf("Error removing user from group: %v", err)
		return false, fmt.Errorf("failed to remove user from group: %v", err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		log.Printf("Error getting rows affected: %v", err)
		return false, fmt.Errorf("error confirming removal: %v", err)
	}

	if rowsAffected == 0 {
		return false, fmt.Errorf("user is not a member of the group")
	}

	return true, nil
}

// SetNodePermissions sets the permissions for a node
func (r *mutationResolver) SetNodePermissions(ctx context.Context, nodeID string, permissions int) (*model.Node, error) {
	logAction(fmt.Sprintf("Setting permissions for node %s to %d", nodeID, permissions))

	// Check if user has permission to change permissions
	hasPermission, err := checkPermission(ctx, r.DB, nodeID, PERM_VIEW_PERMISSIONS)
	if err != nil {
		return nil, err
	}

	if !hasPermission {
		return nil, fmt.Errorf("permission denied: cannot view or modify permissions for this node")
	}

	// Update the permissions
	_, err = r.DB.Exec("UPDATE nodes SET permissions = ? WHERE id = ?", permissions, nodeID)
	if err != nil {
		log.Printf("Error updating node permissions: %v", err)
		return nil, fmt.Errorf("failed to update node permissions: %v", err)
	}

	// Get the updated node
	return getNodeWithPermissions(ctx, r.DB, nodeID)
}

// SetNodeOwnership sets the owner (user or group) for a node
func (r *mutationResolver) SetNodeOwnership(ctx context.Context, nodeID string, ownerUserID *string, ownerGroupID *string) (*model.Node, error) {
	logAction(fmt.Sprintf("Setting ownership for node %s", nodeID))

	// Check if user has permission to change permissions
	hasPermission, err := checkPermission(ctx, r.DB, nodeID, PERM_VIEW_PERMISSIONS)
	if err != nil {
		return nil, err
	}

	if !hasPermission {
		return nil, fmt.Errorf("permission denied: cannot view or modify ownership for this node")
	}

	// Validate ownerUserID if provided
	if ownerUserID != nil && *ownerUserID != "" {
		var userExists bool
		err = r.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM users WHERE id = ?)", *ownerUserID).Scan(&userExists)
		if err != nil {
			log.Printf("Error checking if user exists: %v", err)
			return nil, fmt.Errorf("failed to check if user exists: %v", err)
		}

		if !userExists {
			return nil, fmt.Errorf("user not found")
		}
	}

	// Validate ownerGroupID if provided
	if ownerGroupID != nil && *ownerGroupID != "" {
		var groupExists bool
		err = r.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM groups WHERE id = ?)", *ownerGroupID).Scan(&groupExists)
		if err != nil {
			log.Printf("Error checking if group exists: %v", err)
			return nil, fmt.Errorf("failed to check if group exists: %v", err)
		}

		if !groupExists {
			return nil, fmt.Errorf("group not found")
		}
	}

	// Update the ownership
	query := "UPDATE nodes SET"
	args := []interface{}{}

	if ownerUserID != nil {
		if *ownerUserID == "" {
			query += " owner_user_id = NULL"
		} else {
			query += " owner_user_id = ?"
			args = append(args, *ownerUserID)
		}
	}

	if ownerGroupID != nil {
		if len(args) > 0 {
			query += ","
		}

		if *ownerGroupID == "" {
			query += " owner_group_id = NULL"
		} else {
			query += " owner_group_id = ?"
			args = append(args, *ownerGroupID)
		}
	}

	query += " WHERE id = ?"
	args = append(args, nodeID)

	_, err = r.DB.Exec(query, args...)
	if err != nil {
		log.Printf("Error updating node ownership: %v", err)
		return nil, fmt.Errorf("failed to update node ownership: %v", err)
	}

	// Get the updated node
	return getNodeWithPermissions(ctx, r.DB, nodeID)
}

// CreateUser creates a new user with the provided username, password and optional name
func (r *mutationResolver) CreateUser(ctx context.Context, username string, password string, name *string) (*model.User, error) {
	logAction(fmt.Sprintf("Creating new user with username: %s", username))

	// Get current user from context to verify permissions
	currentUserID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthorized: %v", err)
	}

	// Check if the current user is an administrator or has PERM_MANAGE_USER permission
	var isAdmin bool
	err = r.DB.QueryRow(`
		SELECT EXISTS(
			SELECT 1 
			FROM group_members gm
			JOIN groups g ON gm.group_id = g.id
			WHERE gm.user_id = ? AND g.name = 'Administrators'
		)
	`, currentUserID).Scan(&isAdmin)

	if err != nil {
		log.Printf("Error checking admin status: %v", err)
		return nil, fmt.Errorf("failed to check administrator status: %v", err)
	}

	if !isAdmin {
		return nil, fmt.Errorf("permission denied: must be an administrator to create users")
	}

	// Check if username already exists
	var exists bool
	err = r.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM users WHERE username = ?)", username).Scan(&exists)
	if err != nil {
		log.Printf("Error checking if user exists: %v", err)
		return nil, fmt.Errorf("internal server error: %v", err)
	}

	if exists {
		return nil, fmt.Errorf("username already taken")
	}

	// Default name to username if not provided
	userName := username
	if name != nil && *name != "" {
		userName = *name
	}

	// Hash the password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		log.Printf("Error hashing password: %v", err)
		return nil, fmt.Errorf("internal server error: %v", err)
	}

	// Insert the new user
	result, err := r.DB.Exec(
		"INSERT INTO users (username, name, password_hash, created_at) VALUES (?, ?, ?, datetime('now'))",
		username, userName, string(hashedPassword),
	)
	if err != nil {
		log.Printf("Error creating user: %v", err)
		return nil, fmt.Errorf("failed to create user: %v", err)
	}

	userID, err := result.LastInsertId()
	if err != nil {
		log.Printf("Error retrieving user ID: %v", err)
		return nil, fmt.Errorf("failed to retrieve user ID: %v", err)
	}

	log.Printf("User created successfully with ID: %d", userID)

	// Return the created user
	return &model.User{
		ID:       fmt.Sprintf("%d", userID),
		Name:     userName,
		Username: username,
	}, nil
}

// UpdateUser updates an existing user's username and/or name
func (r *mutationResolver) UpdateUser(ctx context.Context, id string, username *string, name *string) (*model.User, error) {
	logAction(fmt.Sprintf("Updating user with ID: %s", id))

	// Get current user from context to verify permissions
	currentUserID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthorized: %v", err)
	}

	// Check if the user exists
	var exists bool
	err = r.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM users WHERE id = ?)", id).Scan(&exists)
	if err != nil {
		log.Printf("Error checking if user exists: %v", err)
		return nil, fmt.Errorf("failed to check if user exists: %v", err)
	}

	if !exists {
		return nil, fmt.Errorf("user not found")
	}

	// Special protection for user 1 (admin)
	userIDInt, _ := strconv.Atoi(id)
	if userIDInt == 1 {
		// For user 1, only allow updates if the current user is user 1
		currentUserIDInt, _ := strconv.Atoi(currentUserID)
		if currentUserIDInt != 1 {
			return nil, fmt.Errorf("permission denied: only user 1 can update their own account information")
		}
	} else {
		// For other users, check if current user is an admin
		var isAdmin bool
		err = r.DB.QueryRow(`
			SELECT EXISTS(
				SELECT 1 
				FROM group_members gm
				JOIN groups g ON gm.group_id = g.id
				WHERE gm.user_id = ? AND g.name = 'Administrators'
			)
		`, currentUserID).Scan(&isAdmin)

		if err != nil {
			log.Printf("Error checking admin status: %v", err)
			return nil, fmt.Errorf("failed to check administrator status: %v", err)
		}

		if !isAdmin {
			return nil, fmt.Errorf("permission denied: must be an administrator to update users")
		}
	}

	// Check if username already exists (if username is being changed)
	if username != nil && *username != "" {
		var usernameExists bool
		err = r.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM users WHERE username = ? AND id != ?)", *username, id).Scan(&usernameExists)
		if err != nil {
			log.Printf("Error checking if username exists: %v", err)
			return nil, fmt.Errorf("failed to check if username exists: %v", err)
		}

		if usernameExists {
			return nil, fmt.Errorf("username already taken")
		}
	}

	// Build update query dynamically based on which fields are provided
	query := "UPDATE users SET"
	args := []interface{}{}
	requiresComma := false

	if username != nil && *username != "" {
		query += " username = ?"
		args = append(args, *username)
		requiresComma = true
	}

	if name != nil {
		if requiresComma {
			query += ","
		}
		query += " name = ?"
		args = append(args, *name)
	}

	// If no fields were provided, return the user without updating
	if len(args) == 0 {
		return r.getUserById(ctx, id)
	}

	query += " WHERE id = ?"
	args = append(args, id)

	// Execute the update
	_, err = r.DB.Exec(query, args...)
	if err != nil {
		log.Printf("Error updating user: %v", err)
		return nil, fmt.Errorf("failed to update user: %v", err)
	}

	log.Printf("User with ID %s updated successfully", id)

	// Return the updated user
	return r.getUserById(ctx, id)
}

// UpdateUserPassword updates a user's password (requires admin or self with special rules for user 1)
func (r *mutationResolver) UpdateUserPassword(ctx context.Context, userID string, newPassword string) (bool, error) {
	logAction(fmt.Sprintf("Updating password for user ID: %s", userID))

	// Get current user from context to verify permissions
	currentUserID, err := getUserIDFromContext(ctx)
	if err != nil {
		return false, fmt.Errorf("unauthorized: %v", err)
	}

	// Check if target user exists
	var exists bool
	err = r.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM users WHERE id = ?)", userID).Scan(&exists)
	if err != nil {
		log.Printf("Error checking if user exists: %v", err)
		return false, fmt.Errorf("failed to check if user exists: %v", err)
	}

	if !exists {
		return false, fmt.Errorf("user not found")
	}

	// Special protection for user 1 (admin)
	userIDInt, _ := strconv.Atoi(userID)
	currentUserIDInt, _ := strconv.Atoi(currentUserID)

	if userIDInt == 1 {
		// Only user 1 can update user 1's password
		if currentUserIDInt != 1 {
			return false, fmt.Errorf("permission denied: only user 1 can update their own password")
		}
	} else {
		// For other users, check if current user is an admin or the user themselves
		var isAdmin bool
		if currentUserIDInt != userIDInt {
			// If not updating own password, must be admin
			err = r.DB.QueryRow(`
				SELECT EXISTS(
					SELECT 1 
					FROM group_members gm
					JOIN groups g ON gm.group_id = g.id
					WHERE gm.user_id = ? AND g.name = 'Administrators'
				)
			`, currentUserID).Scan(&isAdmin)

			if err != nil {
				log.Printf("Error checking admin status: %v", err)
				return false, fmt.Errorf("failed to check administrator status: %v", err)
			}

			if !isAdmin {
				return false, fmt.Errorf("permission denied: must be an administrator to update another user's password")
			}
		}
	}

	// Hash the new password
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(newPassword), bcrypt.DefaultCost)
	if err != nil {
		log.Printf("Error hashing password: %v", err)
		return false, fmt.Errorf("internal server error: %v", err)
	}

	// Update the password
	_, err = r.DB.Exec("UPDATE users SET password_hash = ? WHERE id = ?", string(hashedPassword), userID)
	if err != nil {
		log.Printf("Error updating password: %v", err)
		return false, fmt.Errorf("failed to update password: %v", err)
	}

	log.Printf("Password updated successfully for user ID: %s", userID)
	return true, nil
}

// DeleteUser deletes a user by ID (with protection for admin user)
func (r *mutationResolver) DeleteUser(ctx context.Context, id string) (bool, error) {
	logAction(fmt.Sprintf("Attempting to delete user with ID: %s", id))

	// Get current user from context to verify permissions
	currentUserID, err := getUserIDFromContext(ctx)
	if err != nil {
		return false, fmt.Errorf("unauthorized: %v", err)
	}

	// Special protection for user 1 (admin) - cannot be deleted
	userIDInt, err := strconv.Atoi(id)
	if err != nil {
		return false, fmt.Errorf("invalid user ID: %v", err)
	}

	if userIDInt == 1 {
		return false, fmt.Errorf("permission denied: the admin user (ID 1) cannot be deleted")
	}

	// Check if the user exists
	var exists bool
	err = r.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM users WHERE id = ?)", id).Scan(&exists)
	if err != nil {
		log.Printf("Error checking if user exists: %v", err)
		return false, fmt.Errorf("failed to check if user exists: %v", err)
	}

	if !exists {
		return false, fmt.Errorf("user not found")
	}

	// Check if the current user is an administrator
	var isAdmin bool
	err = r.DB.QueryRow(`
		SELECT EXISTS(
			SELECT 1 
			FROM group_members gm
			JOIN groups g ON gm.group_id = g.id
			WHERE gm.user_id = ? AND g.name = 'Administrators'
		)
	`, currentUserID).Scan(&isAdmin)

	if err != nil {
		log.Printf("Error checking admin status: %v", err)
		return false, fmt.Errorf("failed to check administrator status: %v", err)
	}

	if !isAdmin {
		return false, fmt.Errorf("permission denied: must be an administrator to delete users")
	}

	// Begin a transaction to handle user deletion
	tx, err := r.DB.Begin()
	if err != nil {
		log.Printf("Error starting transaction: %v", err)
		return false, fmt.Errorf("internal server error: %v", err)
	}
	defer func() {
		if err != nil {
			tx.Rollback()
		}
	}()

	// Delete user's group memberships
	_, err = tx.Exec("DELETE FROM group_members WHERE user_id = ?", id)
	if err != nil {
		log.Printf("Error deleting user group memberships: %v", err)
		return false, fmt.Errorf("failed to delete user group memberships: %v", err)
	}

	// Delete user's settings
	_, err = tx.Exec("DELETE FROM user_settings WHERE user_id = ?", id)
	if err != nil {
		log.Printf("Error deleting user settings: %v", err)
		return false, fmt.Errorf("failed to delete user settings: %v", err)
	}

	// Set any nodes owned by this user to NULL owner
	_, err = tx.Exec("UPDATE nodes SET owner_user_id = NULL WHERE owner_user_id = ?", id)
	if err != nil {
		log.Printf("Error updating node ownership: %v", err)
		return false, fmt.Errorf("failed to update node ownership: %v", err)
	}

	// Finally, delete the user
	result, err := tx.Exec("DELETE FROM users WHERE id = ?", id)
	if err != nil {
		log.Printf("Error deleting user: %v", err)
		return false, fmt.Errorf("failed to delete user: %v", err)
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		log.Printf("Error getting rows affected: %v", err)
		return false, fmt.Errorf("error confirming deletion: %v", err)
	}

	if rowsAffected == 0 {
		tx.Rollback()
		return false, fmt.Errorf("user not found")
	}

	// Commit the transaction
	if err = tx.Commit(); err != nil {
		log.Printf("Error committing transaction: %v", err)
		return false, fmt.Errorf("failed to commit transaction: %v", err)
	}

	log.Printf("User with ID %s deleted successfully", id)
	return true, nil
}

// GetFiles är resolvern för getFiles-fältet
// Hämtar alla filer från databasen med tillhörande metadata
func (r *queryResolver) GetFiles(ctx context.Context) ([]*model.File, error) {
	logAction("Fetching all files from the database")

	// Hämtar alla filer från databasen
	rows, err := r.DB.Query("SELECT id, name, size, content_type, created_at, file_data, node_id FROM files")
	if err != nil {
		log.Printf("Error fetching files from database: %v", err)
		return nil, fmt.Errorf("failed to fetch files: %v", err)
	}
	defer rows.Close()

	var files []*model.File
	for rows.Next() {
		var file model.File
		var createdAt string
		var fileData []byte
		var nodeID sql.NullString
		if err := rows.Scan(&file.ID, &file.Name, &file.Size, &file.ContentType, &createdAt, &fileData, &nodeID); err != nil {
			log.Printf("Error scanning file row: %v", err)
			return nil, fmt.Errorf("failed to scan file row: %v", err)
		}
		file.CreatedAt = createdAt
		if fileData != nil {
			encodedFileData := base64.StdEncoding.EncodeToString(fileData)
			file.FileData = &encodedFileData
		}

		// Set the nodeId on the file
		if nodeID.Valid {
			nodeIDStr := nodeID.String
			file.NodeID = &nodeIDStr
		}

		// Hämtar metadata för varje fil
		metaRows, err := r.DB.Query("SELECT key, value FROM metadata WHERE file_id = ?", file.ID)
		if err != nil {
			log.Printf("Error fetching metadata for file ID %s: %v", file.ID, err)
			return nil, fmt.Errorf("failed to fetch metadata: %v", err)
		}
		defer metaRows.Close()

		var metadata []*model.Metadata
		for metaRows.Next() {
			var meta model.Metadata
			if err := metaRows.Scan(&meta.Key, &meta.Value); err != nil {
				log.Printf("Error scanning metadata row: %v", err)
				return nil, fmt.Errorf("failed to scan metadata row: %v", err)
			}
			metadata = append(metadata, &meta)
		}
		file.Metadata = metadata
		files = append(files, &file)
	}

	if err := rows.Err(); err != nil {
		log.Printf("Error iterating over file rows: %v", err)
		return nil, fmt.Errorf("failed to iterate over file rows: %v", err)
	}

	log.Printf("Successfully fetched %d files", len(files))
	return files, nil
}

// GetFile är resolvern för getFile-fältet
// Hämtar en specifik fil baserat på ID utan binärdata
func (r *queryResolver) GetFile(ctx context.Context, id string) (*model.File, error) {
	logAction(fmt.Sprintf("Fetching file with ID: %s", id))

	if r.DB == nil {
		err := fmt.Errorf("database connection is not initialized")
		log.Printf("GetFile failed: %v", err)
		return nil, err
	}

	// Hämtar filinformation från databasen utan binärdata
	var file model.File
	var createdAt string
	err := r.DB.QueryRow(`
		SELECT id, name, size, content_type, created_at
		FROM files WHERE id = ?`, id).Scan(
		&file.ID, &file.Name, &file.Size, &file.ContentType, &createdAt)

	if err == sql.ErrNoRows {
		errMsg := fmt.Sprintf("file not found with ID: %s", id)
		log.Printf("GetFile failed: %s", errMsg)
		return nil, fmt.Errorf(errMsg)
	} else if err != nil {
		log.Printf("GetFile failed: Error fetching file with ID %s: %v", id, err)
		return nil, fmt.Errorf("failed to fetch file: %v", err)
	}

	file.CreatedAt = createdAt

	// Hämtar metadata för filen
	metaRows, err := r.DB.Query("SELECT key, value FROM metadata WHERE file_id = ?", file.ID)
	if err != nil {
		log.Printf("Error fetching metadata for file ID %s: %v", file.ID, err)
		return nil, fmt.Errorf("failed to fetch metadata: %v", err)
	}
	defer metaRows.Close()

	var metadata []*model.Metadata
	for metaRows.Next() {
		var meta model.Metadata
		if err := metaRows.Scan(&meta.Key, &meta.Value); err != nil {
			log.Printf("Error scanning metadata row: %v", err)
			return nil, fmt.Errorf("failed to scan metadata row: %v", err)
		}
		metadata = append(metadata, &meta)
	}
	file.Metadata = metadata

	log.Printf("Successfully fetched file %s (ID: %s)", file.Name, file.ID)
	return &file, nil
}

// DownloadFile är resolvern för downloadFile-fältet
// Hämtar en fil för nedladdning baserat på ID
func (r *queryResolver) DownloadFile(ctx context.Context, id string) (*model.File, error) {
	logAction(fmt.Sprintf("Attempting to download file with ID: %s", id))

	if r.DB == nil {
		err := fmt.Errorf("database connection is not initialized")
		log.Printf("Download failed: %v", err)
		return nil, err
	}

	// Hämtar filinformation från databasen
	var file model.File
	var createdAt string
	var fileData []byte
	err := r.DB.QueryRow(`
		SELECT id, name, size, content_type, created_at, file_data 
		FROM files WHERE id = ?`, id).Scan(
		&file.ID, &file.Name, &file.Size, &file.ContentType, &createdAt, &fileData)

	if err == sql.ErrNoRows {
		errMsg := fmt.Sprintf("file not found with ID: %s", id)
		log.Printf("Download failed: %s", errMsg)
		return nil, fmt.Errorf(errMsg)
	} else if err != nil {
		log.Printf("Download failed: Error fetching file with ID %s: %v", id, err)
		return nil, fmt.Errorf("failed to fetch file: %v", err)
	}

	file.CreatedAt = createdAt
	if fileData != nil {
		encodedFileData := base64.StdEncoding.EncodeToString(fileData)
		file.FileData = &encodedFileData
	}

	// Hämtar metadata för filen
	metaRows, err := r.DB.Query("SELECT key, value FROM metadata WHERE file_id = ?", file.ID)
	if err != nil {
		log.Printf("Error fetching metadata for file ID %s: %v", file.ID, err)
		return nil, fmt.Errorf("failed to fetch metadata: %v", err)
	}
	defer metaRows.Close()

	var metadata []*model.Metadata
	for metaRows.Next() {
		var meta model.Metadata
		if err := metaRows.Scan(&meta.Key, &meta.Value); err != nil {
			log.Printf("Error scanning metadata row: %v", err)
			return nil, fmt.Errorf("failed to scan metadata row: %v", err)
		}
		metadata = append(metadata, &meta)
	}
	file.Metadata = metadata

	log.Printf("Successfully prepared file %s (ID: %s) for download", file.Name, file.ID)
	return &file, nil
}

// Correcting the method name to match the expected interface
func (r *queryResolver) GetFilesByNodeID(ctx context.Context, nodeID string) ([]*model.File, error) {
	return r.GetFilesByNodeId(ctx, nodeID)
}

// GetRootNodes hämtar alla noder som inte har någon förälder (top-level noder)
func (r *queryResolver) GetRootNodes(ctx context.Context) ([]*model.Node, error) {
	logAction("Fetching root nodes")

	if r.DB == nil {
		return nil, fmt.Errorf("database connection is not initialized")
	}

	rows, err := r.DB.Query(`
		SELECT id, name, parent_id, created_at, updated_at 
		FROM nodes 
		WHERE parent_id IS NULL
		ORDER BY name ASC
	`)
	if err != nil {
		log.Printf("Error fetching root nodes: %v", err)
		return nil, fmt.Errorf("failed to fetch root nodes: %v", err)
	}
	defer rows.Close()

	return scanNodeRows(rows)
}

// GetNodeByID is the resolver for the getNodeById field.
func (r *queryResolver) GetNodeByID(ctx context.Context, id string) (*model.Node, error) {
	logAction(fmt.Sprintf("Fetching node with ID: %s", id))

	if r.DB == nil {
		return nil, fmt.Errorf("database connection is not initialized")
	}

	// Use the helper function that also checks permissions
	return getNodeWithPermissions(ctx, r.DB, id)
}

// GetChildNodes hämtar alla noder som har ett specifikt förälder-ID
func (r *queryResolver) GetChildNodes(ctx context.Context, parentID string) ([]*model.Node, error) {
	logAction(fmt.Sprintf("Fetching child nodes for parent ID: %s", parentID))

	if r.DB == nil {
		return nil, fmt.Errorf("database connection is not initialized")
	}

	// Kontrollera att föräldern finns
	var exists bool
	err := r.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM nodes WHERE id = ?)", parentID).Scan(&exists)
	if err != nil {
		log.Printf("Error checking if parent node exists: %v", err)
		return nil, fmt.Errorf("failed to check if parent node exists: %v", err)
	}

	if !exists {
		log.Printf("Parent node with ID %s does not exist", parentID)
		return nil, fmt.Errorf("parent node not found")
	}

	rows, err := r.DB.Query(`
		SELECT id, name, parent_id, created_at, updated_at 
		FROM nodes 
		WHERE parent_id = ?
		ORDER BY name ASC
	`, parentID)
	if err != nil {
		log.Printf("Error fetching child nodes: %v", err)
		return nil, fmt.Errorf("failed to fetch child nodes: %v", err)
	}
	defer rows.Close()

	return scanNodeRows(rows)
}

// Hello implementerar Query.hello
func (r *queryResolver) Hello(ctx context.Context) (string, error) {
	return "Hello from GraphQL!", nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	logAction("Fetching current user from JWT token")

	// Get the token from the context
	token, ok := GetAuthToken(ctx)
	if !ok {
		return nil, fmt.Errorf("not authenticated")
	}

	// Parse and validate the token
	claims, err := validateJWT(token)
	if err != nil {
		log.Printf("Error validating JWT token: %v", err)
		return nil, fmt.Errorf("not authenticated")
	}

	// Get user ID from claims
	userID, ok := claims["user_id"].(string)
	if !ok {
		log.Printf("Invalid token claims: user_id not found")
		return nil, fmt.Errorf("invalid authentication token")
	}

	// Get username from claims
	username, ok := claims["username"].(string)
	if !ok {
		log.Printf("Invalid token claims: username not found")
		return nil, fmt.Errorf("invalid authentication token")
	}

	// Return user information
	return &model.User{
		ID:       userID,
		Name:     username, // Using username as name for simplicity
		Username: username,
	}, nil
}

// getUserSettings is the resolver for the getUserSettings field
func (r *queryResolver) GetUserSettings(ctx context.Context) ([]*model.UserSetting, error) {
	logAction("Fetching current user settings")

	// Get user ID from JWT token
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// Query the database for all settings for this user
	rows, err := r.DB.Query(`
		SELECT id, key, value, created_at, updated_at
		FROM user_settings
		WHERE user_id = ?
		ORDER BY key ASC
	`, userID)

	if err != nil {
		log.Printf("Error fetching user settings: %v", err)
		return nil, fmt.Errorf("failed to fetch user settings: %v", err)
	}
	defer rows.Close()

	var settings []*model.UserSetting
	for rows.Next() {
		var setting model.UserSetting
		var createdAt, updatedAt string
		if err := rows.Scan(&setting.ID, &setting.Key, &setting.Value, &createdAt, &updatedAt); err != nil {
			log.Printf("Error scanning user setting row: %v", err)
			return nil, fmt.Errorf("failed to read user settings: %v", err)
		}
		setting.CreatedAt = createdAt
		setting.UpdatedAt = updatedAt
		settings = append(settings, &setting)
	}

	if err := rows.Err(); err != nil {
		log.Printf("Error iterating through user settings rows: %v", err)
		return nil, fmt.Errorf("error reading user settings: %v", err)
	}

	return settings, nil
}

// getUserSetting is the resolver for the getUserSetting field
func (r *queryResolver) GetUserSetting(ctx context.Context, key string) (*model.UserSetting, error) {
	logAction(fmt.Sprintf("Fetching user setting with key: %s", key))

	// Get user ID from JWT token
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// Query the database for the specific setting
	var setting model.UserSetting
	var createdAt, updatedAt string
	err = r.DB.QueryRow(`
		SELECT id, key, value, created_at, updated_at
		FROM user_settings
		WHERE user_id = ? AND key = ?
	`, userID, key).Scan(&setting.ID, &setting.Key, &setting.Value, &createdAt, &updatedAt)

	if err == sql.ErrNoRows {
		return nil, nil // Return nil if setting not found
	} else if err != nil {
		log.Printf("Error fetching user setting: %v", err)
		return nil, fmt.Errorf("failed to fetch user setting: %v", err)
	}

	setting.CreatedAt = createdAt
	setting.UpdatedAt = updatedAt

	return &setting, nil
}

// GetGroups returns all groups in the system
func (r *queryResolver) GetGroups(ctx context.Context) ([]*model.Group, error) {
	logAction("Fetching all groups")

	// Only users with permission to view permissions should see all groups
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// Check if the user is an administrator
	var isAdmin bool
	err = r.DB.QueryRow(`
		SELECT EXISTS(
			SELECT 1 
			FROM group_members gm
			JOIN groups g ON gm.group_id = g.id
			WHERE gm.user_id = ? AND g.name = 'Administrators'
		)
	`, userID).Scan(&isAdmin)

	if err != nil {
		log.Printf("Error checking admin status: %v", err)
		return nil, fmt.Errorf("failed to check administrator status: %v", err)
	}

	if !isAdmin {
		return nil, fmt.Errorf("permission denied: must be an administrator to view all groups")
	}

	// Query all groups
	rows, err := r.DB.Query(`
		SELECT id, name
		FROM groups
		ORDER BY name ASC
	`)
	if err != nil {
		log.Printf("Error fetching groups: %v", err)
		return nil, fmt.Errorf("failed to fetch groups: %v", err)
	}
	defer rows.Close()

	var groups []*model.Group
	for rows.Next() {
		var group model.Group
		if err := rows.Scan(&group.ID, &group.Name); err != nil {
			log.Printf("Error scanning group row: %v", err)
			return nil, fmt.Errorf("failed to scan group row: %v", err)
		}
		groups = append(groups, &group)
	}

	if err := rows.Err(); err != nil {
		log.Printf("Error iterating over group rows: %v", err)
		return nil, fmt.Errorf("failed to iterate over group rows: %v", err)
	}

	return groups, nil
}

// GetGroup returns a single group by ID
func (r *queryResolver) GetGroup(ctx context.Context, id string) (*model.Group, error) {
	logAction(fmt.Sprintf("Fetching group with ID: %s", id))

	// Only users with permission to view permissions should see group details
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// Check if the user is an administrator or is in the requested group
	var hasPermission bool
	err = r.DB.QueryRow(`
		SELECT EXISTS(
			SELECT 1 
			FROM group_members gm
			JOIN groups g ON gm.group_id = g.id
			WHERE gm.user_id = ? AND (g.name = 'Administrators' OR gm.group_id = ?)
		)
	`, userID, id).Scan(&hasPermission)

	if err != nil {
		log.Printf("Error checking group permission: %v", err)
		return nil, fmt.Errorf("failed to check group permission: %v", err)
	}

	if !hasPermission {
		return nil, fmt.Errorf("permission denied: can only view groups you are a member of")
	}

	// Query the group
	var group model.Group
	err = r.DB.QueryRow(`
		SELECT id, name
		FROM groups
		WHERE id = ?
	`, id).Scan(&group.ID, &group.Name)

	if err == sql.ErrNoRows {
		return nil, fmt.Errorf("group not found")
	} else if err != nil {
		log.Printf("Error fetching group: %v", err)
		return nil, fmt.Errorf("failed to fetch group: %v", err)
	}

	// Get members of the group
	memberRows, err := r.DB.Query(`
		SELECT u.id, u.username
		FROM users u
		JOIN group_members gm ON u.id = gm.user_id
		WHERE gm.group_id = ?
		ORDER BY u.username ASC
	`, id)
	if err != nil {
		log.Printf("Error fetching group members: %v", err)
		return nil, fmt.Errorf("failed to fetch group members: %v", err)
	}
	defer memberRows.Close()

	var members []*model.User
	for memberRows.Next() {
		var user model.User
		if err := memberRows.Scan(&user.ID, &user.Username); err != nil {
			log.Printf("Error scanning user row: %v", err)
			return nil, fmt.Errorf("failed to scan user row: %v", err)
		}
		user.Name = user.Username // Using username as name for simplicity
		members = append(members, &user)
	}

	if err := memberRows.Err(); err != nil {
		log.Printf("Error iterating over member rows: %v", err)
		return nil, fmt.Errorf("failed to iterate over member rows: %v", err)
	}

	group.Members = members
	return &group, nil
}

// GetUserGroups returns groups that the current user is a member of
func (r *queryResolver) GetUserGroups(ctx context.Context) ([]*model.Group, error) {
	logAction("Fetching groups for current user")

	// Get user ID from context
	userID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	return getUserGroups(ctx, r.DB, userID)
}

// GetUserByID returns a user by ID
func (r *queryResolver) GetUserByID(ctx context.Context, id string) (*model.User, error) {
	logAction(fmt.Sprintf("Fetching user with ID: %s", id))

	// Only users with permission to view user information should be able to do this
	currentUserID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	// If user is requesting their own info, allow it
	if currentUserID == id {
		// Self-lookup is always allowed
	} else {
		// Otherwise, check if user has admin privileges
		var isAdmin bool
		err = r.DB.QueryRow(`
			SELECT EXISTS(
				SELECT 1 
				FROM group_members gm
				JOIN groups g ON gm.group_id = g.id
				WHERE gm.user_id = ? AND g.name = 'Administrators'
			)
		`, currentUserID).Scan(&isAdmin)

		if err != nil {
			log.Printf("Error checking admin status: %v", err)
			return nil, fmt.Errorf("failed to check administrator status: %v", err)
		}

		if !isAdmin {
			return nil, fmt.Errorf("permission denied: must be an administrator to view other users")
		}
	}

	// Query the user
	var user model.User
	err = r.DB.QueryRow(`
		SELECT id, username
		FROM users
		WHERE id = ?
	`, id).Scan(&user.ID, &user.Username)

	if err == sql.ErrNoRows {
		return nil, fmt.Errorf("user not found")
	} else if err != nil {
		log.Printf("Error fetching user: %v", err)
		return nil, fmt.Errorf("failed to fetch user: %v", err)
	}

	user.Name = user.Username // Using username as name for simplicity

	// Get groups for the user
	groups, err := getUserGroups(ctx, r.DB, id)
	if err != nil {
		log.Printf("Error fetching user groups: %v", err)
		// Continue without groups - not a critical error
	} else {
		user.Groups = groups
	}

	return &user, nil
}

// GetUsers returns all users in the system
func (r *queryResolver) GetUsers(ctx context.Context) ([]*model.User, error) {
	logAction("Fetching all users")

	// Get current user from context to verify permissions
	currentUserID, err := getUserIDFromContext(ctx)
	if err != nil {
		return nil, fmt.Errorf("unauthorized: %v", err)
	}

	// Check if the current user is an administrator
	var isAdmin bool
	err = r.DB.QueryRow(`
		SELECT EXISTS(
			SELECT 1 
			FROM group_members gm
			JOIN groups g ON gm.group_id = g.id
			WHERE gm.user_id = ? AND g.name = 'Administrators'
		)
	`, currentUserID).Scan(&isAdmin)

	if err != nil {
		log.Printf("Error checking admin status: %v", err)
		return nil, fmt.Errorf("failed to check administrator status: %v", err)
	}

	if !isAdmin {
		return nil, fmt.Errorf("permission denied: must be an administrator to list all users")
	}

	// Query all users
	rows, err := r.DB.Query("SELECT id, username, name FROM users")
	if err != nil {
		log.Printf("Error querying users: %v", err)
		return nil, fmt.Errorf("failed to query users: %v", err)
	}
	defer rows.Close()

	var users []*model.User
	for rows.Next() {
		var user model.User
		if err := rows.Scan(&user.ID, &user.Username, &user.Name); err != nil {
			log.Printf("Error scanning user row: %v", err)
			return nil, fmt.Errorf("failed to scan user data: %v", err)
		}
		users = append(users, &user)
	}

	if err := rows.Err(); err != nil {
		log.Printf("Error iterating through users: %v", err)
		return nil, fmt.Errorf("error reading user data: %v", err)
	}

	return users, nil
}

// User implementerar Todo.user
func (r *todoResolver) User(ctx context.Context, obj *model.Todo) (*model.User, error) {
	return &model.User{
		ID:   "1", // Exempel-ID eftersom detta är en dummy-implementation
		Name: "Example User",
	}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Todo returns TodoResolver implementation.
func (r *Resolver) Todo() TodoResolver { return &todoResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type todoResolver struct{ *Resolver }
